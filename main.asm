; w65c02 assembly code for 'main'
; generated by prog8.codegen.cpu6502.ProgramAndVarsGen on 2023-12-05T11:30:06
; assembler syntax is for the 64tasm cross-assembler
; output options: output=PRG launcher=BASIC zp=BASICSAFE

.cpu  'w65c02'
.enc  'none'
P8ZP_SCRATCH_B1 = 122
P8ZP_SCRATCH_REG = 123
P8ZP_SCRATCH_W1 = 124    ; word
P8ZP_SCRATCH_W2 = 126    ; word
.weak
.endweak
; ---- basic program with sys call ----
* = $0801
	.word  (+), 2023
	.null  $9e, format(' %d ', prog8_entrypoint), $3a, $8f, ' prog8'
+	.word  0
prog8_entrypoint	; assembly code starts here
	jsr  sys.init_system_phase2
	jsr  p8_main.p8_start
	jmp  sys.cleanup_at_exit

; ---- block: 'p8_main' ----
p8_main	.proc
	; source: src\main.p8:8   main {

; non-zeropage variables without initialization value
	.section BSS
p8_fpm	.fill  12
	.send BSS

	; source: src\main.p8:11   ubyte[fmalloc_root.SIZEOF_FMALLOC] fpm;
	; source: src\main.p8:13   sub start() {

p8_start	.proc
; program startup initialization
	cld
	tsx
	stx  prog8_lib.orig_stackpointer    ; required for sys.exit()
	.if  prog8_bss_section_size>0
	; reset all variables in BSS section to zero
	lda  #<prog8_bss_section_start
	ldy  #>prog8_bss_section_start
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldx  #<prog8_bss_section_size
	ldy  #>prog8_bss_section_size
	lda  #0
	jsr  prog8_lib.memset
	.endif
+        
	clv
	clc
; statements
	; source: src\main.p8:15   txt.print("p8test\n");
	ldy  #>prog8_interned_strings.string_1+0
	lda  #<prog8_interned_strings.string_1+0
	jsr  txt.print
	; source: src\main.p8:17   fmalloc_init();
	jsr  p8_main.p8_fmalloc_init
	; source: src\main.p8:18   linkedlist_test();
	jmp  p8_main.p8_linkedlist_test
	; source: src\main.p8:13   sub start() {
; variables
	.section BSS
	.send BSS

	.pend
	; source: src\main.p8:32   sub linkedlist_test() {

p8_linkedlist_test	.proc
p8_i 	= 34 	; zp UWORD
; statements
	; source: src\main.p8:35   ubyte[fptr.SIZEOF_FPTR] ptr1;
	; source: src\main.p8:36   ubyte[fptr.SIZEOF_FPTR] pText;
	; source: src\main.p8:39   ubyte[fptr.SIZEOF_FPTR] llr;
	; source: src\main.p8:45   str test = "               ";
	; source: src\main.p8:49   uword i;
	; source: src\main.p8:42   linkedlist.init(&fpm, &llr);
	lda  #<p8_main.p8_fpm+0
	ldy  #>p8_main.p8_fpm+0
	sta  p8_linkedlist.p8_init.p8_heap
	sty  p8_linkedlist.p8_init.p8_heap+1
	
	lda  #<p8_llr+0
	ldy  #>p8_llr+0
	sta  p8_linkedlist.p8_init.p8_root
	sty  p8_linkedlist.p8_init.p8_root+1
	
	jsr  p8_linkedlist.p8_init
	; source: library:/prog8lib/cx16/textio.p8:19   txt.chrout(147)
	lda  #$93
	jsr  txt.chrout
	; source: src\main.p8:50   for i in 1 to $100 {
	lda  #<1
	ldy  #>1
	sta  p8_i
	sty  p8_i+1
prog8_label_asm_1_for_loop
	; source: src\main.p8:53   conv.str_uwhex(i)
	ldy  p8_i+1
	lda  p8_i
	jsr  conv.str_uwhex
	; source: src\main.p8:54   test = "test: ";
	lda  #<prog8_interned_strings.string_2+0
	sta  cx16.r0
	lda  #>prog8_interned_strings.string_2+0
	sta  cx16.r0+1
	
	ldy  #>p8_main.p8_linkedlist_test.p8_test+0
	lda  #<p8_main.p8_linkedlist_test.p8_test+0
	jsr  sys.internal_stringcopy
	; source: src\main.p8:55   void string.copy(conv.string_out, &test + 6);
	ldy  #>p8_test+0
	lda  #<p8_test+0
	clc
	adc  #<6
	tax
	tya
	adc  #>6
	tay
	txa
	pha
	phy
	ldy  #>conv.string_out+0
	lda  #<conv.string_out+0
	pha
  tya
	sta  cx16.r0+1
	pla
	sta  cx16.r0
	ply
	pla
	jsr  string.copy
	; source: src\main.p8:58   fmalloc.malloc(&fpm, 16, pText)
	lda  #<p8_main.p8_fpm+0
	ldy  #>p8_main.p8_fpm+0
	sta  p8_fmalloc.p8_malloc.p8_pm
	sty  p8_fmalloc.p8_malloc.p8_pm+1
	
	lda  #<$10
	ldy  #>$10
	sta  p8_fmalloc.p8_malloc.p8_size
	sty  p8_fmalloc.p8_malloc.p8_size+1
	
	lda  #<p8_pText+0
	ldy  #>p8_pText+0
	sta  p8_fmalloc.p8_malloc.p8_result
	sty  p8_fmalloc.p8_malloc.p8_result+1
	
	jsr  p8_fmalloc.p8_malloc
	; source: src\main.p8:59   fptr.memcopy_in(&pText, &test, 11);
	lda  #<p8_pText+0
	sta  cx16.r0
	lda  #>p8_pText+0
	sta  cx16.r0+1
	
	lda  #<p8_test+0
	sta  cx16.r1
	lda  #>p8_test+0
	sta  cx16.r1+1
	
	ldx  #11
	jsr  p8_fptr.p8_memcopy_in
	; source: src\main.p8:62   linkedlist.add_last(&fpm, llr, &pText, ptr1);
	lda  #<p8_main.p8_fpm+0
	ldy  #>p8_main.p8_fpm+0
	sta  p8_linkedlist.p8_add_last.p8_heap
	sty  p8_linkedlist.p8_add_last.p8_heap+1
	
	lda  #<p8_llr+0
	ldy  #>p8_llr+0
	sta  p8_linkedlist.p8_add_last.p8_root
	sty  p8_linkedlist.p8_add_last.p8_root+1
	
	lda  #<p8_pText+0
	ldy  #>p8_pText+0
	sta  p8_linkedlist.p8_add_last.p8_data
	sty  p8_linkedlist.p8_add_last.p8_data+1
	
	lda  #<p8_ptr1+0
	ldy  #>p8_ptr1+0
	sta  p8_linkedlist.p8_add_last.p8_result
	sty  p8_linkedlist.p8_add_last.p8_result+1
	
	jsr  p8_linkedlist.p8_add_last
	; source: library:/prog8lib/cx16/textio.p8:23   txt.chrout(19)
	lda  #$13
	jsr  txt.chrout
	; source: src\main.p8:66   dump_fptr("ptext: ", pText);
	lda  #<prog8_interned_strings.string_3+0
	ldy  #>prog8_interned_strings.string_3+0
	sta  p8_main.p8_dump_fptr.p8_prompt
	sty  p8_main.p8_dump_fptr.p8_prompt+1
	
	lda  #<p8_pText+0
	ldy  #>p8_pText+0
	sta  p8_main.p8_dump_fptr.p8_fptr
	sty  p8_main.p8_dump_fptr.p8_fptr+1
	
	jsr  p8_main.p8_dump_fptr
	; source: src\main.p8:67   dump_fptr(" ptr1: ", ptr1);
	lda  #<prog8_interned_strings.string_4+0
	ldy  #>prog8_interned_strings.string_4+0
	sta  p8_main.p8_dump_fptr.p8_prompt
	sty  p8_main.p8_dump_fptr.p8_prompt+1
	
	lda  #<p8_ptr1+0
	ldy  #>p8_ptr1+0
	sta  p8_main.p8_dump_fptr.p8_fptr
	sty  p8_main.p8_dump_fptr.p8_fptr+1
	
	jsr  p8_main.p8_dump_fptr
	; source: src\main.p8:68   txt.print(" ");
	lda  #$20
	jsr  txt.chrout
	; source: src\main.p8:69   txt.print(test);
	ldy  #>p8_main.p8_linkedlist_test.p8_test+0
	lda  #<p8_main.p8_linkedlist_test.p8_test+0
	jsr  txt.print
	lda  p8_i
	cmp  #<256
	bne  +
	lda  p8_i+1
	cmp  #>256
	beq  prog8_label_asm_2_for_end
+           inc  p8_i
	bne  prog8_label_asm_1_for_loop
	inc  p8_i+1
	bra  prog8_label_asm_1_for_loop
prog8_label_asm_2_for_end
	; source: library:/prog8lib/cx16/textio.p8:19   txt.chrout(147)
	lda  #$93
	jsr  txt.chrout
	; source: src\main.p8:75   linkedlist.first(&llr, ptr1);
	lda  #<p8_llr+0
	ldy  #>p8_llr+0
	sta  p8_linkedlist.p8_first.p8_root
	sty  p8_linkedlist.p8_first.p8_root+1
	
	lda  #<p8_ptr1+0
	ldy  #>p8_ptr1+0
	sta  p8_linkedlist.p8_first.p8_result
	sty  p8_linkedlist.p8_first.p8_result+1
	
	jsr  p8_linkedlist.p8_first
	; source: src\main.p8:76   while fptr.compare(&ptr1, &fptr.NULL) != fptr.compare_equal {
p8_prog8_label_1_whileloop
	lda  #<p8_ptr1+0
	ldy  #>p8_ptr1+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #0
	beq  p8_prog8_label_2_afterwhile
	; source: src\main.p8:79   linkedlist_item.data_get(ptr1, pText);
	lda  #<p8_ptr1+0
	ldy  #>p8_ptr1+0
	sta  p8_linkedlist_item.p8_data_get.p8_ptr
	sty  p8_linkedlist_item.p8_data_get.p8_ptr+1
	
	lda  #<p8_pText+0
	ldy  #>p8_pText+0
	sta  p8_linkedlist_item.p8_data_get.p8_result
	sty  p8_linkedlist_item.p8_data_get.p8_result+1
	
	jsr  p8_linkedlist_item.p8_data_get
	; source: src\main.p8:80   fptr.memcopy_out(&pText, &test, 15);
	lda  #<p8_pText+0
	sta  cx16.r0
	lda  #>p8_pText+0
	sta  cx16.r0+1
	
	lda  #<p8_test+0
	sta  cx16.r1
	lda  #>p8_test+0
	sta  cx16.r1+1
	
	ldx  #15
	jsr  p8_fptr.p8_memcopy_out
	; source: src\main.p8:83   txt.print("\n");
	lda  #13
	jsr  txt.chrout
	; source: src\main.p8:84   dump_fptr("ptext: ", pText);
	lda  #<prog8_interned_strings.string_3+0
	ldy  #>prog8_interned_strings.string_3+0
	sta  p8_main.p8_dump_fptr.p8_prompt
	sty  p8_main.p8_dump_fptr.p8_prompt+1
	
	lda  #<p8_pText+0
	ldy  #>p8_pText+0
	sta  p8_main.p8_dump_fptr.p8_fptr
	sty  p8_main.p8_dump_fptr.p8_fptr+1
	
	jsr  p8_main.p8_dump_fptr
	; source: src\main.p8:85   dump_fptr(" ptr1: ", ptr1);
	lda  #<prog8_interned_strings.string_4+0
	ldy  #>prog8_interned_strings.string_4+0
	sta  p8_main.p8_dump_fptr.p8_prompt
	sty  p8_main.p8_dump_fptr.p8_prompt+1
	
	lda  #<p8_ptr1+0
	ldy  #>p8_ptr1+0
	sta  p8_main.p8_dump_fptr.p8_fptr
	sty  p8_main.p8_dump_fptr.p8_fptr+1
	
	jsr  p8_main.p8_dump_fptr
	; source: src\main.p8:86   txt.print(" ");
	lda  #$20
	jsr  txt.chrout
	; source: src\main.p8:87   txt.print(test);
	ldy  #>p8_main.p8_linkedlist_test.p8_test+0
	lda  #<p8_main.p8_linkedlist_test.p8_test+0
	jsr  txt.print
	; source: src\main.p8:90   linkedlist.next(ptr1, ptr1);
	lda  #<p8_ptr1+0
	ldy  #>p8_ptr1+0
	sta  p8_linkedlist.p8_next.p8_current
	sty  p8_linkedlist.p8_next.p8_current+1
	
	sta  p8_linkedlist.p8_next.p8_result
	sty  p8_linkedlist.p8_next.p8_result+1
	
	jsr  p8_linkedlist.p8_next
	; source: src\main.p8:76   while fptr.compare(&ptr1, &fptr.NULL) != fptr.compare_equal {
	bra  p8_prog8_label_1_whileloop
p8_prog8_label_2_afterwhile
	; source: library:/prog8lib/cx16/textio.p8:19   txt.chrout(147)
	lda  #$93
	jsr  txt.chrout
	; source: src\main.p8:96   linkedlist.last(&llr, ptr1);
	lda  #<p8_llr+0
	ldy  #>p8_llr+0
	sta  p8_linkedlist.p8_last.p8_root
	sty  p8_linkedlist.p8_last.p8_root+1
	
	lda  #<p8_ptr1+0
	ldy  #>p8_ptr1+0
	sta  p8_linkedlist.p8_last.p8_result
	sty  p8_linkedlist.p8_last.p8_result+1
	
	jsr  p8_linkedlist.p8_last
	; source: src\main.p8:97   while fptr.compare(&ptr1, &fptr.NULL) != fptr.compare_equal {
p8_prog8_label_3_whileloop
	lda  #<p8_ptr1+0
	ldy  #>p8_ptr1+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #0
	beq  p8_prog8_label_4_afterwhile
	; source: src\main.p8:100   linkedlist_item.data_get(ptr1, pText);
	lda  #<p8_ptr1+0
	ldy  #>p8_ptr1+0
	sta  p8_linkedlist_item.p8_data_get.p8_ptr
	sty  p8_linkedlist_item.p8_data_get.p8_ptr+1
	
	lda  #<p8_pText+0
	ldy  #>p8_pText+0
	sta  p8_linkedlist_item.p8_data_get.p8_result
	sty  p8_linkedlist_item.p8_data_get.p8_result+1
	
	jsr  p8_linkedlist_item.p8_data_get
	; source: src\main.p8:101   fptr.memcopy_out(&pText, &test, 15);
	lda  #<p8_pText+0
	sta  cx16.r0
	lda  #>p8_pText+0
	sta  cx16.r0+1
	
	lda  #<p8_test+0
	sta  cx16.r1
	lda  #>p8_test+0
	sta  cx16.r1+1
	
	ldx  #15
	jsr  p8_fptr.p8_memcopy_out
	; source: src\main.p8:104   txt.print("\n");
	lda  #13
	jsr  txt.chrout
	; source: src\main.p8:105   dump_fptr("ptext: ", pText);
	lda  #<prog8_interned_strings.string_3+0
	ldy  #>prog8_interned_strings.string_3+0
	sta  p8_main.p8_dump_fptr.p8_prompt
	sty  p8_main.p8_dump_fptr.p8_prompt+1
	
	lda  #<p8_pText+0
	ldy  #>p8_pText+0
	sta  p8_main.p8_dump_fptr.p8_fptr
	sty  p8_main.p8_dump_fptr.p8_fptr+1
	
	jsr  p8_main.p8_dump_fptr
	; source: src\main.p8:106   dump_fptr(" ptr1: ", ptr1);
	lda  #<prog8_interned_strings.string_4+0
	ldy  #>prog8_interned_strings.string_4+0
	sta  p8_main.p8_dump_fptr.p8_prompt
	sty  p8_main.p8_dump_fptr.p8_prompt+1
	
	lda  #<p8_ptr1+0
	ldy  #>p8_ptr1+0
	sta  p8_main.p8_dump_fptr.p8_fptr
	sty  p8_main.p8_dump_fptr.p8_fptr+1
	
	jsr  p8_main.p8_dump_fptr
	; source: src\main.p8:107   txt.print(" ");
	lda  #$20
	jsr  txt.chrout
	; source: src\main.p8:108   txt.print(test);
	ldy  #>p8_main.p8_linkedlist_test.p8_test+0
	lda  #<p8_main.p8_linkedlist_test.p8_test+0
	jsr  txt.print
	; source: src\main.p8:111   linkedlist.prev(ptr1, ptr1);
	lda  #<p8_ptr1+0
	ldy  #>p8_ptr1+0
	sta  p8_linkedlist.p8_prev.p8_current
	sty  p8_linkedlist.p8_prev.p8_current+1
	
	sta  p8_linkedlist.p8_prev.p8_result
	sty  p8_linkedlist.p8_prev.p8_result+1
	
	jsr  p8_linkedlist.p8_prev
	; source: src\main.p8:97   while fptr.compare(&ptr1, &fptr.NULL) != fptr.compare_equal {
	bra  p8_prog8_label_3_whileloop
p8_prog8_label_4_afterwhile
	; source: src\main.p8:116   linkedlist.free(&fpm, &llr);
	lda  #<p8_main.p8_fpm+0
	ldy  #>p8_main.p8_fpm+0
	sta  p8_linkedlist.p8_free.p8_heap
	sty  p8_linkedlist.p8_free.p8_heap+1
	
	lda  #<p8_llr+0
	ldy  #>p8_llr+0
	sta  p8_linkedlist.p8_free.p8_root
	sty  p8_linkedlist.p8_free.p8_root+1
	
	jmp  p8_linkedlist.p8_free
	; source: src\main.p8:32   sub linkedlist_test() {
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_llr	.fill  3
p8_pText	.fill  3
p8_ptr1	.fill  3
	.send BSS
; non-zeropage variables
p8_test	; PETSCII:"               "
	.byte  $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $00
	.pend
	; source: src\main.p8:120   sub fmalloc_init() {

p8_fmalloc_init	.proc
p8_bank 	= 36 	; zp UBYTE
; statements
	; source: src\main.p8:126   ubyte[fptr.SIZEOF_FPTR] fheap1;
	; source: src\main.p8:131   ubyte bank;
	; source: src\main.p8:123   fmalloc.init(&fpm);
	ldy  #>p8_main.p8_fpm+0
	lda  #<p8_main.p8_fpm+0
	jsr  p8_fmalloc.p8_init
	; source: src\main.p8:127   fheap1[1] = $00;
	stz  p8_fheap1+1
	; source: src\main.p8:128   fheap1[2] = $a0;
	lda  #$a0
	sta  p8_fheap1+2
	; source: src\main.p8:132   for bank in 1 to 63 {
	lda  #1
	sta  p8_bank
prog8_label_asm_3_for_loop
	; source: src\main.p8:133   fheap1[0] = bank
	lda  p8_bank
	sta  p8_fheap1+0
	; source: src\main.p8:134   fmalloc.addblock(&fpm, fheap1, 8192);
	lda  #<p8_main.p8_fpm+0
	ldy  #>p8_main.p8_fpm+0
	sta  p8_fmalloc.p8_addblock.p8_pm
	sty  p8_fmalloc.p8_addblock.p8_pm+1
	
	lda  #<p8_fheap1+0
	ldy  #>p8_fheap1+0
	sta  p8_fmalloc.p8_addblock.p8_ptr
	sty  p8_fmalloc.p8_addblock.p8_ptr+1
	
	lda  #<$2000
	ldy  #>$2000
	sta  p8_fmalloc.p8_addblock.p8_size
	sty  p8_fmalloc.p8_addblock.p8_size+1
	
	jsr  p8_fmalloc.p8_addblock
	inc  p8_bank
	lda  p8_bank
	cmp  #64
	bne  prog8_label_asm_3_for_loop
prog8_label_asm_4_for_end
	; source: src\main.p8:120   sub fmalloc_init() {
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_fheap1	.fill  3
	.send BSS
	.pend
	; source: src\main.p8:139   sub dump_fptr(str prompt, ubyte[fptr.SIZEOF_FPTR] fptr)

p8_dump_fptr	.proc
p8_prompt 	= 37 	; zp UWORD
p8_fptr 	= 39 	; zp UWORD
; statements
	; source: src\main.p8:141   txt.print(prompt);
	ldy  p8_prompt+1
	lda  p8_prompt
	jsr  txt.print
	; source: src\main.p8:142   conv.str_ubhex(fptr[0])
	ldy  #0
	lda  (p8_fptr),y
	jsr  conv.str_ubhex
	; source: src\main.p8:143   txt.print(conv.string_out);
	ldy  #>conv.string_out+0
	lda  #<conv.string_out+0
	jsr  txt.print
	; source: src\main.p8:144   txt.print(":");
	lda  #$3a
	jsr  txt.chrout
	; source: src\main.p8:145   conv.str_ubhex(fptr[2])
	ldy  #2
	lda  (p8_fptr),y
	jsr  conv.str_ubhex
	; source: src\main.p8:146   txt.print(conv.string_out);
	ldy  #>conv.string_out+0
	lda  #<conv.string_out+0
	jsr  txt.print
	; source: src\main.p8:147   conv.str_ubhex(fptr[1])
	ldy  #1
	lda  (p8_fptr),y
	jsr  conv.str_ubhex
	; source: src\main.p8:148   txt.print(conv.string_out);
	ldy  #>conv.string_out+0
	lda  #<conv.string_out+0
	jmp  txt.print
	; source: src\main.p8:139   sub dump_fptr(str prompt, ubyte[fptr.SIZEOF_FPTR] fptr)
; variables
	.section BSS
	.send BSS

	.pend
	.pend

; ---- block: 'prog8_interned_strings' ----
prog8_interned_strings	.proc

; non-zeropage variables
string_1	; PETSCII:"p8test\n"
	.byte  $50, $38, $54, $45, $53, $54, $0d, $00
string_2	; PETSCII:"test: "
	.byte  $54, $45, $53, $54, $3a, $20, $00
string_3	; PETSCII:"ptext: "
	.byte  $50, $54, $45, $58, $54, $3a, $20, $00
string_4	; PETSCII:" ptr1: "
	.byte  $20, $50, $54, $52, $31, $3a, $20, $00

	; source: src\main.p8:15   txt.print("p8test\n");
	; source: src\main.p8:54   test = "test: ";
	; source: src\main.p8:66   dump_fptr("ptext: ", pText);
	; source: src\main.p8:67   dump_fptr(" ptr1: ", ptr1);
	.pend

; ---- block: 'txt' ----
txt	.proc
	; source: library:/prog8lib/cx16/textio.p8:7   txt {
	DEFAULT_HEIGHT = $3c
	DEFAULT_WIDTH = $50
	VERA_TEXTMATRIX_ADDR = $b000
	VERA_TEXTMATRIX_BANK = 1

	chrout = $ffd2

	; source: library:/prog8lib/cx16/textio.p8:11   const ubyte DEFAULT_WIDTH = 80
	; source: library:/prog8lib/cx16/textio.p8:12   const ubyte DEFAULT_HEIGHT = 60
	; source: library:/prog8lib/cx16/textio.p8:14   const ubyte VERA_TEXTMATRIX_BANK = 1
	; source: library:/prog8lib/cx16/textio.p8:15   const uword VERA_TEXTMATRIX_ADDR = $b000
	; source: library:/prog8lib/cx16/textio.p8:9   %option no_symbol_prefixing
	; source: library:/prog8lib/cx16/textio.p8:34   asmsub column(ubyte col @A) clobbers(A, X, Y) {

column	.proc
	; source: library:/prog8lib/cx16/textio.p8:36   %asm {{
        sec
        jsr  cbm.PLOT
        tay
        clc
        jmp  cbm.PLOT
	.pend
	; source: library:/prog8lib/cx16/textio.p8:45   asmsub  fill_screen (ubyte character @ A, ubyte color @ Y) clobbers(A, X)  {

fill_screen	.proc
	; source: library:/prog8lib/cx16/textio.p8:47   %asm {{
        sty  _ly+1
        pha
        jsr  cbm.SCREEN             ; get dimensions in X/Y
        txa
        lsr  a
        lsr  a
        sta  _lx+1
        lda  #%00010000
        jsr  set_vera_textmatrix_addresses
        pla
_lx     ldx  #0                     ; modified
        phy
_ly     ldy  #1                     ; modified
-       sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        dex
        bne  -
        ply
        dey
        beq  +
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M       ; next line
        bra  _lx
+       rts

set_vera_textmatrix_addresses:
        stz  cx16.VERA_CTRL
        ora  #VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H
        stz  cx16.VERA_ADDR_L       ; start at (0,0)
        lda  #>VERA_TEXTMATRIX_ADDR
        sta  cx16.VERA_ADDR_M
        rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:91   asmsub  clear_screenchars (ubyte character @ A) clobbers(X, Y)  {

clear_screenchars	.proc
	; source: library:/prog8lib/cx16/textio.p8:94   %asm {{
        pha
        jsr  cbm.SCREEN             ; get dimensions in X/Y
        txa
        lsr  a
        lsr  a
        sta  _lx+1
        lda  #%00100000
        jsr  fill_screen.set_vera_textmatrix_addresses
        pla
_lx     ldx  #0                     ; modified
-       sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        dex
        bne  -
        dey
        beq  +
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M       ; next line
        bra  _lx
+       rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:120   asmsub  clear_screencolors (ubyte color @ A) clobbers(X, Y)  {

clear_screencolors	.proc
	; source: library:/prog8lib/cx16/textio.p8:123   %asm {{
        sta  _la+1
        jsr  cbm.SCREEN             ; get dimensions in X/Y
        txa
        lsr  a
        lsr  a
        sta  _lx+1
        stz  cx16.VERA_CTRL
        lda  #%00100000
        jsr  fill_screen.set_vera_textmatrix_addresses
        inc  cx16.VERA_ADDR_L       ; start at (1,0) - the color attribute byte
_lx     ldx  #0                     ; modified
_la     lda  #0                     ; modified
-       sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        dex
        bne  -
        dey
        beq  +
        lda  #1
        sta  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M       ; next line
        bra  _lx
+       rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:189   asmsub  scroll_left() clobbers(A, X, Y)  {

scroll_left	.proc
	; source: library:/prog8lib/cx16/textio.p8:192   %asm {{
	    jsr  cbm.SCREEN
	    dex
	    stx  _lx+1
        dey
        sty  P8ZP_SCRATCH_B1    ; number of rows to scroll

_nextline
        stz  cx16.VERA_CTRL     ; data port 0: source column
        lda  #%00010000 | VERA_TEXTMATRIX_BANK        ; auto increment 1
        sta  cx16.VERA_ADDR_H
        lda  #2
        sta  cx16.VERA_ADDR_L   ; begin in column 1
        lda  P8ZP_SCRATCH_B1
        clc
        adc  #>VERA_TEXTMATRIX_ADDR
        tay
        sty  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL     ; data port 1: destination column
        lda  #%00010000  | VERA_TEXTMATRIX_BANK         ; auto increment 1
        sta  cx16.VERA_ADDR_H
        stz  cx16.VERA_ADDR_L
        sty  cx16.VERA_ADDR_M

_lx     ldx  #0                ; modified
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        bpl  _nextline

        lda  #0
        sta  cx16.VERA_CTRL
	    rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:233   asmsub  scroll_right() clobbers(A,X,Y)  {

scroll_right	.proc
	; source: library:/prog8lib/cx16/textio.p8:236   %asm {{
	    jsr  cbm.SCREEN
	    dex
	    stx  _lx+1
	    txa
	    asl  a
	    dea
	    sta  _rcol+1
	    ina
	    ina
	    sta  _rcol2+1
        dey
        sty  P8ZP_SCRATCH_B1    ; number of rows to scroll

_nextline
        stz  cx16.VERA_CTRL     ; data port 0: source column
        lda  #%00011000 | VERA_TEXTMATRIX_BANK        ; auto decrement 1
        sta  cx16.VERA_ADDR_H
_rcol   lda  #79*2-1            ; modified
        sta  cx16.VERA_ADDR_L   ; begin in rightmost column minus one
        lda  P8ZP_SCRATCH_B1
        clc
        adc  #>VERA_TEXTMATRIX_ADDR
        tay
        sty  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL     ; data port 1: destination column
        lda  #%00011000 | VERA_TEXTMATRIX_BANK        ; auto decrement 1
        sta  cx16.VERA_ADDR_H
_rcol2  lda  #79*2+1           ; modified
        sta  cx16.VERA_ADDR_L
        sty  cx16.VERA_ADDR_M

_lx     ldx  #0                 ; modified
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        bpl  _nextline

        lda  #0
        sta  cx16.VERA_CTRL
	    rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:285   asmsub  scroll_up() clobbers(A, X, Y)  {

scroll_up	.proc
	; source: library:/prog8lib/cx16/textio.p8:288   %asm {{
	    jsr  cbm.SCREEN
	    stx  _nextline+1
	    dey
        sty  P8ZP_SCRATCH_B1
        stz  cx16.VERA_CTRL         ; data port 0 is source
        lda  #1 | (>VERA_TEXTMATRIX_ADDR)
        sta  cx16.VERA_ADDR_M       ; start at second line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1 is destination
        lda  #>VERA_TEXTMATRIX_ADDR
        sta  cx16.VERA_ADDR_M       ; start at top line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

_nextline
        ldx  #80        ; modified
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        beq  +
        stz  cx16.VERA_CTRL         ; data port 0
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M
        bra  _nextline

+       lda  #0
        sta  cx16.VERA_CTRL
	    rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:333   asmsub  scroll_down() clobbers(A, X, Y)  {

scroll_down	.proc
	; source: library:/prog8lib/cx16/textio.p8:336   %asm {{
	    jsr  cbm.SCREEN
	    stx  _nextline+1
	    dey
        sty  P8ZP_SCRATCH_B1
        stz  cx16.VERA_CTRL         ; data port 0 is source
        dey
        tya
        clc
        adc  #>VERA_TEXTMATRIX_ADDR
        sta  cx16.VERA_ADDR_M       ; start at line before bottom line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1 is destination
        iny
        tya
        clc
        adc  #>VERA_TEXTMATRIX_ADDR
        sta  cx16.VERA_ADDR_M       ; start at bottom line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

_nextline
        ldx  #80        ; modified
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        beq  +
        stz  cx16.VERA_CTRL         ; data port 0
        stz  cx16.VERA_ADDR_L
        dec  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1
        stz  cx16.VERA_ADDR_L
        dec  cx16.VERA_ADDR_M
        bra  _nextline

+       lda  #0
        sta  cx16.VERA_CTRL
	    rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:387   romsub $FFD2 = chrout(ubyte character @ A)    ; for consistency. You can also use cbm.CHROUT directly ofcourse.

	; source: library:/prog8lib/cx16/textio.p8:389   asmsub  print (str text @ AY) clobbers(A,Y)  {

print	.proc
	; source: library:/prog8lib/cx16/textio.p8:394   %asm {{
		sta  P8ZP_SCRATCH_B1
		sty  P8ZP_SCRATCH_REG
		ldy  #0
-		lda  (P8ZP_SCRATCH_B1),y
		beq  +
		jsr  cbm.CHROUT
		iny
		bne  -
+		rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:407   asmsub  print_ub0  (ubyte value @ A) clobbers(A,X,Y)  {

print_ub0	.proc
	; source: library:/prog8lib/cx16/textio.p8:409   %asm {{
		jsr  conv.ubyte2decimal
		pha
		tya
		jsr  cbm.CHROUT
		pla
		jsr  cbm.CHROUT
		txa
		jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/cx16/textio.p8:421   asmsub  print_ub  (ubyte value @ A) clobbers(A,X,Y)  {

print_ub	.proc
	; source: library:/prog8lib/cx16/textio.p8:423   %asm {{
		jsr  conv.ubyte2decimal
_print_byte_digits
		pha
		cpy  #'0'
		beq  +
		tya
		jsr  cbm.CHROUT
		pla
		jsr  cbm.CHROUT
		bra  _ones
+       pla
        cmp  #'0'
        beq  _ones
        jsr  cbm.CHROUT
_ones   txa
		jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/cx16/textio.p8:443   asmsub  print_b  (byte value @ A) clobbers(A,X,Y)  {

print_b	.proc
	; source: library:/prog8lib/cx16/textio.p8:445   %asm {{
		pha
		cmp  #0
		bpl  +
		lda  #'-'
		jsr  cbm.CHROUT
+		pla
		jsr  conv.byte2decimal
		bra  print_ub._print_byte_digits
	.pend
	; source: library:/prog8lib/cx16/textio.p8:457   asmsub  print_ubhex  (ubyte value @ A, bool prefix @ Pc) clobbers(A,X,Y)  {

print_ubhex	.proc
	; source: library:/prog8lib/cx16/textio.p8:459   %asm {{
		bcc  +
		pha
		lda  #'$'
		jsr  cbm.CHROUT
		pla
+		jsr  conv.ubyte2hex
		jsr  cbm.CHROUT
		tya
		jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/cx16/textio.p8:472   asmsub  print_ubbin  (ubyte value @ A, bool prefix @ Pc) clobbers(A,X,Y)  {

print_ubbin	.proc
	; source: library:/prog8lib/cx16/textio.p8:474   %asm {{
		sta  P8ZP_SCRATCH_B1
		bcc  +
		lda  #'%'
		jsr  cbm.CHROUT
+		ldy  #8
-		lda  #'0'
		asl  P8ZP_SCRATCH_B1
		bcc  +
		lda  #'1'
+		jsr  cbm.CHROUT
		dey
		bne  -
		rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:491   asmsub  print_uwbin  (uword value @ AY, bool prefix @ Pc) clobbers(A,X,Y)  {

print_uwbin	.proc
	; source: library:/prog8lib/cx16/textio.p8:493   %asm {{
		pha
		tya
		jsr  print_ubbin
		pla
		clc
		bra  print_ubbin
	.pend
	; source: library:/prog8lib/cx16/textio.p8:503   asmsub  print_uwhex  (uword value @ AY, bool prefix @ Pc) clobbers(A,X,Y)  {

print_uwhex	.proc
	; source: library:/prog8lib/cx16/textio.p8:506   %asm {{
		pha
		tya
		jsr  print_ubhex
		pla
		clc
		bra  print_ubhex
	.pend
	; source: library:/prog8lib/cx16/textio.p8:516   asmsub  print_uw0  (uword value @ AY) clobbers(A,X,Y)  {

print_uw0	.proc
	; source: library:/prog8lib/cx16/textio.p8:518   %asm {{
		jsr  conv.uword2decimal
		ldy  #0
-		lda  conv.uword2decimal.decTenThousands,y
        beq  +
		jsr  cbm.CHROUT
		iny
		bne  -
+		rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:530   asmsub  print_uw  (uword value @ AY) clobbers(A,X,Y)  {

print_uw	.proc
	; source: library:/prog8lib/cx16/textio.p8:532   %asm {{
		jsr  conv.uword2decimal
		ldy  #0
-		lda  conv.uword2decimal.decTenThousands,y
		beq  _allzero
		cmp  #'0'
		bne  _gotdigit
		iny
		bne  -

_gotdigit
		jsr  cbm.CHROUT
		iny
		lda  conv.uword2decimal.decTenThousands,y
		bne  _gotdigit
		rts
_allzero
        lda  #'0'
        jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/cx16/textio.p8:554   asmsub  print_w  (word value @ AY) clobbers(A,X,Y)  {

print_w	.proc
	; source: library:/prog8lib/cx16/textio.p8:556   %asm {{
		cpy  #0
		bpl  +
		pha
		lda  #'-'
		jsr  cbm.CHROUT
		tya
		eor  #255
		tay
		pla
		eor  #255
		ina
		bne +
		iny
+		bra  print_uw
	.pend
	; source: library:/prog8lib/cx16/textio.p8:574   asmsub  input_chars  (uword buffer @ AY) clobbers(A) -> ubyte @ Y  {

input_chars	.proc
	; source: library:/prog8lib/cx16/textio.p8:578   %asm {{
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0				; char counter = 0
-		jsr  cbm.CHRIN
		cmp  #$0d			; return (ascii 13) pressed?
		beq  +				; yes, end.
		sta  (P8ZP_SCRATCH_W1),y	; else store char in buffer
		iny
		bne  -
+		lda  #0
		sta  (P8ZP_SCRATCH_W1),y	; finish string with 0 byte
		rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:595   asmsub  setchr  (ubyte col @X, ubyte row @Y, ubyte character @A) clobbers(A)  {

setchr	.proc
	; source: library:/prog8lib/cx16/textio.p8:597   %asm {{
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX_BANK
            sta  cx16.VERA_ADDR_H
            txa
            asl  a
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX_ADDR
            sta  cx16.VERA_ADDR_M
            pla
            sta  cx16.VERA_DATA0
            rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:615   asmsub  getchr  (ubyte col @A, ubyte row @Y) -> ubyte @ A {

getchr	.proc
	; source: library:/prog8lib/cx16/textio.p8:617   %asm  {{
            asl  a
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX_BANK
            sta  cx16.VERA_ADDR_H
            pla
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX_ADDR
            sta  cx16.VERA_ADDR_M
            lda  cx16.VERA_DATA0
            rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:634   asmsub  setclr  (ubyte col @X, ubyte row @Y, ubyte color @A) clobbers(A)  {

setclr	.proc
	; source: library:/prog8lib/cx16/textio.p8:638   %asm {{
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX_BANK
            sta  cx16.VERA_ADDR_H
            txa
            asl  a
            ina
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX_ADDR
            sta  cx16.VERA_ADDR_M
            pla
            sta  cx16.VERA_DATA0
            rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:657   asmsub  getclr  (ubyte col @A, ubyte row @Y) -> ubyte @ A {

getclr	.proc
	; source: library:/prog8lib/cx16/textio.p8:659   %asm  {{
            asl  a
            ina
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX_BANK
            sta  cx16.VERA_ADDR_H
            pla
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX_ADDR
            sta  cx16.VERA_ADDR_M
            lda  cx16.VERA_DATA0
            rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:734   asmsub  plot  (ubyte col @ Y, ubyte row @ X) {

plot	.proc
	; source: library:/prog8lib/cx16/textio.p8:735   %asm  {{
		clc
		jmp  cbm.PLOT
	.pend
	; source: library:/prog8lib/cx16/textio.p8:741   asmsub width() clobbers(X,Y) -> ubyte @A {

width	.proc
	; source: library:/prog8lib/cx16/textio.p8:743   %asm {{
        jsr  cbm.SCREEN
        txa
        rts
	.pend
	; source: library:/prog8lib/cx16/textio.p8:750   asmsub height() clobbers(X, Y) -> ubyte @A {

height	.proc
	; source: library:/prog8lib/cx16/textio.p8:752   %asm {{
        jsr  cbm.SCREEN
        tya
        rts
	.pend
	.pend

; ---- block: 'cbm' ----
cbm	.proc
	; source: library:/prog8lib/cx16/syslib.p8:4   cbm {

	CINT = $ff81
	IOINIT = $ff84
	RAMTAS = $ff87
	RESTOR = $ff8a
	VECTOR = $ff8d
	SETMSG = $ff90
	SECOND = $ff93
	TKSA = $ff96
	MEMTOP = $ff99
	MEMBOT = $ff9c
	SCNKEY = $ff9f
	SETTMO = $ffa2
	ACPTR = $ffa5
	CIOUT = $ffa8
	UNTLK = $ffab
	UNLSN = $ffae
	LISTEN = $ffb1
	TALK = $ffb4
	READST = $ffb7
	SETLFS = $ffba
	SETNAM = $ffbd
	OPEN = $ffc0
	CLOSE = $ffc3
	CHKIN = $ffc6
	CHKOUT = $ffc9
	CLRCHN = $ffcc
	CHRIN = $ffcf
	CHROUT = $ffd2
	LOAD = $ffd5
	SAVE = $ffd8
	SETTIM = $ffdb
	RDTIM = $ffde
	STOP = $ffe1
	GETIN = $ffe4
	CLALL = $ffe7
	UDTIM = $ffea
	SCREEN = $ffed
	PLOT = $fff0
	IOBASE = $fff3

	; source: library:/prog8lib/cx16/syslib.p8:8   %option no_symbol_prefixing
	; source: library:/prog8lib/cx16/syslib.p8:14   romsub $FF81 = CINT() clobbers(A,X,Y)                           ; (alias: SCINIT) initialize screen editor and video chip

	; source: library:/prog8lib/cx16/syslib.p8:15   romsub $FF84 = IOINIT() clobbers(A, X)                          ; initialize I/O devices (CIA, SID, IRQ)

	; source: library:/prog8lib/cx16/syslib.p8:16   romsub $FF87 = RAMTAS() clobbers(A,X,Y)                         ; initialize RAM, tape buffer, screen

	; source: library:/prog8lib/cx16/syslib.p8:17   romsub $FF8A = RESTOR() clobbers(A,X,Y)                         ; restore default I/O vectors

	; source: library:/prog8lib/cx16/syslib.p8:18   romsub $FF8D = VECTOR(uword userptr @ XY, bool dir @ Pc) clobbers(A,Y)     ; read/set I/O vector table

	; source: library:/prog8lib/cx16/syslib.p8:19   romsub $FF90 = SETMSG(ubyte value @ A)                          ; set Kernal message control flag

	; source: library:/prog8lib/cx16/syslib.p8:20   romsub $FF93 = SECOND(ubyte address @ A) clobbers(A)            ; (alias: LSTNSA) send secondary address after LISTEN

	; source: library:/prog8lib/cx16/syslib.p8:21   romsub $FF96 = TKSA(ubyte address @ A) clobbers(A)              ; (alias: TALKSA) send secondary address after TALK

	; source: library:/prog8lib/cx16/syslib.p8:22   romsub $FF99 = MEMTOP(uword address @ XY, bool dir @ Pc) -> uword @ XY     ; read/set top of memory  pointer.   NOTE: as a Cx16 extension, also returns the number of RAM memory banks in register A !  See cx16.numbanks()

	; source: library:/prog8lib/cx16/syslib.p8:23   romsub $FF9C = MEMBOT(uword address @ XY, bool dir @ Pc) -> uword @ XY     ; read/set bottom of memory  pointer

	; source: library:/prog8lib/cx16/syslib.p8:24   romsub $FF9F = SCNKEY() clobbers(A,X,Y)                         ; scan the keyboard

	; source: library:/prog8lib/cx16/syslib.p8:25   romsub $FFA2 = SETTMO(ubyte timeout @ A)                        ; set time-out flag for IEEE bus

	; source: library:/prog8lib/cx16/syslib.p8:26   romsub $FFA5 = ACPTR() -> ubyte @ A                             ; (alias: IECIN) input byte from serial bus

	; source: library:/prog8lib/cx16/syslib.p8:27   romsub $FFA8 = CIOUT(ubyte databyte @ A)                        ; (alias: IECOUT) output byte to serial bus

	; source: library:/prog8lib/cx16/syslib.p8:28   romsub $FFAB = UNTLK() clobbers(A)                              ; command serial bus device to UNTALK

	; source: library:/prog8lib/cx16/syslib.p8:29   romsub $FFAE = UNLSN() clobbers(A)                              ; command serial bus device to UNLISTEN

	; source: library:/prog8lib/cx16/syslib.p8:30   romsub $FFB1 = LISTEN(ubyte device @ A) clobbers(A)             ; command serial bus device to LISTEN

	; source: library:/prog8lib/cx16/syslib.p8:31   romsub $FFB4 = TALK(ubyte device @ A) clobbers(A)               ; command serial bus device to TALK

	; source: library:/prog8lib/cx16/syslib.p8:32   romsub $FFB7 = READST() -> ubyte @ A                            ; read I/O status word

	; source: library:/prog8lib/cx16/syslib.p8:33   romsub $FFBA = SETLFS(ubyte logical @ A, ubyte device @ X, ubyte secondary @ Y)   ; set logical file parameters

	; source: library:/prog8lib/cx16/syslib.p8:34   romsub $FFBD = SETNAM(ubyte namelen @ A, str filename @ XY)     ; set filename parameters

	; source: library:/prog8lib/cx16/syslib.p8:35   romsub $FFC0 = OPEN() clobbers(X,Y) -> bool @Pc, ubyte @A      ; (via 794 ($31A)) open a logical file

	; source: library:/prog8lib/cx16/syslib.p8:36   romsub $FFC3 = CLOSE(ubyte logical @ A) clobbers(A,X,Y)         ; (via 796 ($31C)) close a logical file

	; source: library:/prog8lib/cx16/syslib.p8:37   romsub $FFC6 = CHKIN(ubyte logical @ X) clobbers(A,X) -> bool @Pc    ; (via 798 ($31E)) define an input channel

	; source: library:/prog8lib/cx16/syslib.p8:38   romsub $FFC9 = CHKOUT(ubyte logical @ X) clobbers(A,X)          ; (via 800 ($320)) define an output channel

	; source: library:/prog8lib/cx16/syslib.p8:39   romsub $FFCC = CLRCHN() clobbers(A,X)                           ; (via 802 ($322)) restore default devices

	; source: library:/prog8lib/cx16/syslib.p8:40   romsub $FFCF = CHRIN() clobbers(X, Y) -> ubyte @ A   ; (via 804 ($324)) input a character (for keyboard, read a whole line from the screen) A=byte read.

	; source: library:/prog8lib/cx16/syslib.p8:41   romsub $FFD2 = CHROUT(ubyte character @ A)                           ; (via 806 ($326)) output a character

	; source: library:/prog8lib/cx16/syslib.p8:42   romsub $FFD5 = LOAD(ubyte verify @ A, uword address @ XY) -> bool @Pc, ubyte @ A, uword @ XY     ; (via 816 ($330)) load from device

	; source: library:/prog8lib/cx16/syslib.p8:43   romsub $FFD8 = SAVE(ubyte zp_startaddr @ A, uword endaddr @ XY) clobbers (X, Y) -> bool @ Pc, ubyte @ A       ; (via 818 ($332)) save to a device

	; source: library:/prog8lib/cx16/syslib.p8:44   romsub $FFDB = SETTIM(ubyte low @ A, ubyte middle @ X, ubyte high @ Y)      ; set the software clock

	; source: library:/prog8lib/cx16/syslib.p8:45   romsub $FFDE = RDTIM() -> ubyte @ A, ubyte @ X, ubyte @ Y       ; read the software clock (A=lo,X=mid,Y=high)

	; source: library:/prog8lib/cx16/syslib.p8:46   romsub $FFE1 = STOP() clobbers(X) -> bool @ Pz, ubyte @ A      ; (via 808 ($328)) check the STOP key (and some others in A)

	; source: library:/prog8lib/cx16/syslib.p8:47   romsub $FFE4 = GETIN() clobbers(X,Y) -> bool @Pc, ubyte @ A    ; (via 810 ($32A)) get a character

	; source: library:/prog8lib/cx16/syslib.p8:48   romsub $FFE7 = CLALL() clobbers(A,X)                            ; (via 812 ($32C)) close all files

	; source: library:/prog8lib/cx16/syslib.p8:49   romsub $FFEA = UDTIM() clobbers(A,X)                            ; update the software clock

	; source: library:/prog8lib/cx16/syslib.p8:50   romsub $FFED = SCREEN() -> ubyte @ X, ubyte @ Y                 ; read number of screen rows and columns

	; source: library:/prog8lib/cx16/syslib.p8:51   romsub $FFF0 = PLOT(ubyte col @ Y, ubyte row @ X, bool dir @ Pc) -> ubyte @ X, ubyte @ Y       ; read/set position of cursor on screen.  Use txt.plot for a 'safe' wrapper that preserves X.

	; source: library:/prog8lib/cx16/syslib.p8:52   romsub $FFF3 = IOBASE() -> uword @ XY                           ; read base address of I/O devices

	; source: library:/prog8lib/cx16/syslib.p8:56   asmsub STOP2() clobbers(X) -> ubyte @A  {

STOP2	.proc
	; source: library:/prog8lib/cx16/syslib.p8:58   %asm {{
        jsr  cbm.STOP
        beq  +
        lda  #0
        rts
+       lda  #1
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:68   asmsub RDTIM16() clobbers(X) -> uword @AY {

RDTIM16	.proc
	; source: library:/prog8lib/cx16/syslib.p8:70   %asm {{
        php
        sei
        jsr  cbm.RDTIM
        plp
        cli
        pha
        txa
        tay
        pla
        rts
	.pend
	.pend

; ---- block: 'cx16' ----
cx16	.proc
	; source: library:/prog8lib/cx16/syslib.p8:86   cx16 {
	r0 = 2
	r0s = 2
	r0L = 2
	r0sL = 2
	r0H = 3
	r0sH = 3
	r1 = 4
	r1s = 4
	r1L = 4
	r1sL = 4
	r1H = 5
	r1sH = 5
	r2 = 6
	r2s = 6
	r2L = 6
	r2sL = 6
	r2H = 7
	r2sH = 7
	r3 = 8
	r3s = 8
	r3L = 8
	r3sL = 8
	r3H = 9
	r3sH = 9
	r4 = 10
	r4s = 10
	r4L = 10
	r4sL = 10
	r4H = 11
	r4sH = 11
	r5 = 12
	r5s = 12
	r5L = 12
	r5sL = 12
	r5H = 13
	r5sH = 13
	r6 = 14
	r6s = 14
	r6L = 14
	r6sL = 14
	r6H = 15
	r6sH = 15
	r7 = $10
	r7s = $10
	r7L = $10
	r7sL = $10
	r7H = $11
	r7sH = $11
	r8 = $12
	r8s = $12
	r8L = $12
	r8sL = $12
	r8H = $13
	r8sH = $13
	r9 = $14
	r9s = $14
	r9L = $14
	r9sL = $14
	r9H = $15
	r9sH = $15
	r10 = $16
	r10s = $16
	r10L = $16
	r10sL = $16
	r10H = $17
	r10sH = $17
	r11 = $18
	r11s = $18
	r11L = $18
	r11sL = $18
	r11H = $19
	r11sH = $19
	r12 = $1a
	r12s = $1a
	r12L = $1a
	r12sL = $1a
	r12H = $1b
	r12sH = $1b
	r13 = $1c
	r13s = $1c
	r13L = $1c
	r13sL = $1c
	r13H = $1d
	r13sH = $1d
	r14 = $1e
	r14s = $1e
	r14L = $1e
	r14sL = $1e
	r14H = $1f
	r14sH = $1f
	r15 = $20
	r15s = $20
	r15L = $20
	r15sL = $20
	r15H = $21
	r15sH = $21
	IERROR = $0300
	IMAIN = $0302
	ICRNCH = $0304
	IQPLOP = $0306
	IGONE = $0308
	IEVAL = $030a
	SAREG = $030c
	SXREG = $030d
	SYREG = $030e
	SPREG = $030f
	USRADD = $0311
	CINV = $0314
	CBINV = $0316
	NMINV = $0318
	IOPEN = $031a
	ICLOSE = $031c
	ICHKIN = $031e
	ICKOUT = $0320
	ICLRCH = $0322
	IBASIN = $0324
	IBSOUT = $0326
	ISTOP = $0328
	IGETIN = $032a
	ICLALL = $032c
	KEYHDL = $032e
	ILOAD = $0330
	ISAVE = $0332
	via1prb = $9f00
	via1pra = $9f01
	via1ddrb = $9f02
	via1ddra = $9f03
	via1t1l = $9f04
	via1t1h = $9f05
	via1t1ll = $9f06
	via1t1lh = $9f07
	via1t2l = $9f08
	via1t2h = $9f09
	via1sr = $9f0a
	via1acr = $9f0b
	via1pcr = $9f0c
	via1ifr = $9f0d
	via1ier = $9f0e
	via1ora = $9f0f
	via2prb = $9f10
	via2pra = $9f11
	via2ddrb = $9f12
	via2ddra = $9f13
	via2t1l = $9f14
	via2t1h = $9f15
	via2t1ll = $9f16
	via2t1lh = $9f17
	via2t2l = $9f18
	via2t2h = $9f19
	via2sr = $9f1a
	via2acr = $9f1b
	via2pcr = $9f1c
	via2ifr = $9f1d
	via2ier = $9f1e
	via2ora = $9f1f
	VERA_ADDR_L = $9f20
	VERA_ADDR_M = $9f21
	VERA_ADDR_H = $9f22
	VERA_DATA0 = $9f23
	VERA_DATA1 = $9f24
	VERA_CTRL = $9f25
	VERA_IEN = $9f26
	VERA_ISR = $9f27
	VERA_IRQ_LINE_L = $9f28
	VERA_DC_VIDEO = $9f29
	VERA_DC_HSTART = $9f29
	VERA_DC_VER0 = $9f29
	VERA_FX_CTRL = $9f29
	VERA_FX_CACHE_L = $9f29
	VERA_FX_ACCUM_RESET = $9f29
	VERA_DC_HSCALE = $9f2a
	VERA_DC_HSTOP = $9f2a
	VERA_DC_VER1 = $9f2a
	VERA_FX_CACHE_M = $9f2a
	VERA_DC_VSCALE = $9f2b
	VERA_DC_VSTART = $9f2b
	VERA_DC_VER2 = $9f2b
	VERA_FX_CACHE_H = $9f2b
	VERA_DC_BORDER = $9f2c
	VERA_DC_VSTOP = $9f2c
	VERA_DC_VER3 = $9f2c
	VERA_FX_MULT = $9f2c
	VERA_FX_CACHE_U = $9f2c
	VERA_L0_CONFIG = $9f2d
	VERA_L0_MAPBASE = $9f2e
	VERA_L0_TILEBASE = $9f2f
	VERA_L0_HSCROLL_L = $9f30
	VERA_L0_HSCROLL_H = $9f31
	VERA_L0_VSCROLL_L = $9f32
	VERA_L0_VSCROLL_H = $9f33
	VERA_L1_CONFIG = $9f34
	VERA_L1_MAPBASE = $9f35
	VERA_L1_TILEBASE = $9f36
	VERA_L1_HSCROLL_L = $9f37
	VERA_L1_HSCROLL_H = $9f38
	VERA_L1_VSCROLL_L = $9f39
	VERA_L1_VSCROLL_H = $9f3a
	VERA_AUDIO_CTRL = $9f3b
	VERA_AUDIO_RATE = $9f3c
	VERA_AUDIO_DATA = $9f3d
	VERA_SPI_DATA = $9f3e
	VERA_SPI_CTRL = $9f3f
	YM_ADDRESS = $9f40
	YM_DATA = $9f41
	NMI_VEC = $fffa
	RESET_VEC = $fffc
	IRQ_VEC = $fffe
	VERA_BASE = $9f20
	VIA1_BASE = $9f00
	VIA2_BASE = $9f10
	extdev = $9f60

	CLOSE_ALL = $ff4a
	LKUPLA = $ff59
	LKUPSA = $ff5c
	screen_mode = $ff5f
	screen_set_charset = $ff62
	JSRFAR = $ff6e
	fetch = $ff74
	stash = $ff77
	PRIMM = $ff7d
	GRAPH_init = $ff20
	GRAPH_clear = $ff23
	GRAPH_set_window = $ff26
	GRAPH_set_colors = $ff29
	GRAPH_draw_line = $ff2c
	GRAPH_draw_rect = $ff2f
	GRAPH_move_rect = $ff32
	GRAPH_draw_oval = $ff35
	GRAPH_draw_image = $ff38
	GRAPH_set_font = $ff3b
	GRAPH_get_char_size = $ff3e
	GRAPH_put_char = $ff41
	GRAPH_put_next_char = $ff41
	FB_init = $fef6
	FB_get_info = $fef9
	FB_set_palette = $fefc
	FB_cursor_position = $feff
	FB_cursor_position2 = $feff
	FB_cursor_next_line = $ff02
	FB_get_pixel = $ff05
	FB_get_pixels = $ff08
	FB_set_pixel = $ff0b
	FB_set_pixels = $ff0e
	FB_set_8_pixels = $ff11
	FB_set_8_pixels_opaque = $ff14
	FB_fill_pixels = $ff17
	FB_filter_pixels = $ff1a
	FB_move_pixels = $ff1d
	BSAVE = $feba
	i2c_read_byte = $fec6
	i2c_write_byte = $fec9
	sprite_set_image = $fef0
	sprite_set_position = $fef3
	memory_fill = $fee4
	memory_copy = $fee7
	memory_crc = $feea
	memory_decompress = $feed
	console_init = $fedb
	console_put_char = $fede
	console_get_char = $fee1
	console_put_image = $fed8
	console_set_paging_message = $fed5
	entropy_get = $fecf
	monitor = $fecc
	MACPTR = $ff44
	MCIOUT = $feb1
	enter_basic = $ff47
	clock_set_date_time = $ff4d
	clock_get_date_time = $ff50
	kbdbuf_peek = $febd
	kbdbuf_peek2 = $febd
	kbdbuf_get_modifiers = $fec0
	kbdbuf_put = $fec3
	keymap = $fed2
	mouse_config = $ff68
	mouse_get = $ff6b
	mouse_scan = $ff71
	joystick_scan = $ff53
	joystick_get = $ff56
	joystick_get2 = $ff56
	psg_init = $c04b
	ym_init = $c063
	ym_loaddefpatches = $c066
	audio_init = $c09f

	; source: library:/prog8lib/cx16/syslib.p8:91   &uword  IERROR      = $0300
	; source: library:/prog8lib/cx16/syslib.p8:92   &uword  IMAIN       = $0302
	; source: library:/prog8lib/cx16/syslib.p8:93   &uword  ICRNCH      = $0304
	; source: library:/prog8lib/cx16/syslib.p8:94   &uword  IQPLOP      = $0306
	; source: library:/prog8lib/cx16/syslib.p8:95   &uword  IGONE       = $0308
	; source: library:/prog8lib/cx16/syslib.p8:96   &uword  IEVAL       = $030a
	; source: library:/prog8lib/cx16/syslib.p8:97   &ubyte  SAREG       = $030c     ; register storage for A for SYS calls
	; source: library:/prog8lib/cx16/syslib.p8:98   &ubyte  SXREG       = $030d     ; register storage for X for SYS calls
	; source: library:/prog8lib/cx16/syslib.p8:99   &ubyte  SYREG       = $030e     ; register storage for Y for SYS calls
	; source: library:/prog8lib/cx16/syslib.p8:100   &ubyte  SPREG       = $030f     ; register storage for P (status register) for SYS calls
	; source: library:/prog8lib/cx16/syslib.p8:101   &uword  USRADD      = $0311     ; vector for the USR() basic command
	; source: library:/prog8lib/cx16/syslib.p8:103   &uword  CINV        = $0314     ; IRQ vector (in ram)
	; source: library:/prog8lib/cx16/syslib.p8:104   &uword  CBINV       = $0316     ; BRK vector (in ram)
	; source: library:/prog8lib/cx16/syslib.p8:105   &uword  NMINV       = $0318     ; NMI vector (in ram)
	; source: library:/prog8lib/cx16/syslib.p8:106   &uword  IOPEN       = $031a
	; source: library:/prog8lib/cx16/syslib.p8:107   &uword  ICLOSE      = $031c
	; source: library:/prog8lib/cx16/syslib.p8:108   &uword  ICHKIN      = $031e
	; source: library:/prog8lib/cx16/syslib.p8:109   &uword  ICKOUT      = $0320
	; source: library:/prog8lib/cx16/syslib.p8:110   &uword  ICLRCH      = $0322
	; source: library:/prog8lib/cx16/syslib.p8:111   &uword  IBASIN      = $0324
	; source: library:/prog8lib/cx16/syslib.p8:112   &uword  IBSOUT      = $0326
	; source: library:/prog8lib/cx16/syslib.p8:113   &uword  ISTOP       = $0328
	; source: library:/prog8lib/cx16/syslib.p8:114   &uword  IGETIN      = $032a
	; source: library:/prog8lib/cx16/syslib.p8:115   &uword  ICLALL      = $032c
	; source: library:/prog8lib/cx16/syslib.p8:116   &uword  KEYHDL      = $032e     ; keyboard scan code handler see examples/cx16/keyboardhandler.p8
	; source: library:/prog8lib/cx16/syslib.p8:117   &uword  ILOAD       = $0330
	; source: library:/prog8lib/cx16/syslib.p8:118   &uword  ISAVE       = $0332
	; source: library:/prog8lib/cx16/syslib.p8:119   &uword  NMI_VEC     = $FFFA     ; 65c02 nmi vector, determined by the kernal if banked in
	; source: library:/prog8lib/cx16/syslib.p8:120   &uword  RESET_VEC   = $FFFC     ; 65c02 reset vector, determined by the kernal if banked in
	; source: library:/prog8lib/cx16/syslib.p8:121   &uword  IRQ_VEC     = $FFFE     ; 65c02 interrupt vector, determined by the kernal if banked in
	; source: library:/prog8lib/cx16/syslib.p8:125   &uword r0  = $0002
	; source: library:/prog8lib/cx16/syslib.p8:126   &uword r1  = $0004
	; source: library:/prog8lib/cx16/syslib.p8:127   &uword r2  = $0006
	; source: library:/prog8lib/cx16/syslib.p8:128   &uword r3  = $0008
	; source: library:/prog8lib/cx16/syslib.p8:129   &uword r4  = $000a
	; source: library:/prog8lib/cx16/syslib.p8:130   &uword r5  = $000c
	; source: library:/prog8lib/cx16/syslib.p8:131   &uword r6  = $000e
	; source: library:/prog8lib/cx16/syslib.p8:132   &uword r7  = $0010
	; source: library:/prog8lib/cx16/syslib.p8:133   &uword r8  = $0012
	; source: library:/prog8lib/cx16/syslib.p8:134   &uword r9  = $0014
	; source: library:/prog8lib/cx16/syslib.p8:135   &uword r10 = $0016
	; source: library:/prog8lib/cx16/syslib.p8:136   &uword r11 = $0018
	; source: library:/prog8lib/cx16/syslib.p8:137   &uword r12 = $001a
	; source: library:/prog8lib/cx16/syslib.p8:138   &uword r13 = $001c
	; source: library:/prog8lib/cx16/syslib.p8:139   &uword r14 = $001e
	; source: library:/prog8lib/cx16/syslib.p8:140   &uword r15 = $0020
	; source: library:/prog8lib/cx16/syslib.p8:142   &word r0s  = $0002
	; source: library:/prog8lib/cx16/syslib.p8:143   &word r1s  = $0004
	; source: library:/prog8lib/cx16/syslib.p8:144   &word r2s  = $0006
	; source: library:/prog8lib/cx16/syslib.p8:145   &word r3s  = $0008
	; source: library:/prog8lib/cx16/syslib.p8:146   &word r4s  = $000a
	; source: library:/prog8lib/cx16/syslib.p8:147   &word r5s  = $000c
	; source: library:/prog8lib/cx16/syslib.p8:148   &word r6s  = $000e
	; source: library:/prog8lib/cx16/syslib.p8:149   &word r7s  = $0010
	; source: library:/prog8lib/cx16/syslib.p8:150   &word r8s  = $0012
	; source: library:/prog8lib/cx16/syslib.p8:151   &word r9s  = $0014
	; source: library:/prog8lib/cx16/syslib.p8:152   &word r10s = $0016
	; source: library:/prog8lib/cx16/syslib.p8:153   &word r11s = $0018
	; source: library:/prog8lib/cx16/syslib.p8:154   &word r12s = $001a
	; source: library:/prog8lib/cx16/syslib.p8:155   &word r13s = $001c
	; source: library:/prog8lib/cx16/syslib.p8:156   &word r14s = $001e
	; source: library:/prog8lib/cx16/syslib.p8:157   &word r15s = $0020
	; source: library:/prog8lib/cx16/syslib.p8:159   &ubyte r0L  = $0002
	; source: library:/prog8lib/cx16/syslib.p8:160   &ubyte r1L  = $0004
	; source: library:/prog8lib/cx16/syslib.p8:161   &ubyte r2L  = $0006
	; source: library:/prog8lib/cx16/syslib.p8:162   &ubyte r3L  = $0008
	; source: library:/prog8lib/cx16/syslib.p8:163   &ubyte r4L  = $000a
	; source: library:/prog8lib/cx16/syslib.p8:164   &ubyte r5L  = $000c
	; source: library:/prog8lib/cx16/syslib.p8:165   &ubyte r6L  = $000e
	; source: library:/prog8lib/cx16/syslib.p8:166   &ubyte r7L  = $0010
	; source: library:/prog8lib/cx16/syslib.p8:167   &ubyte r8L  = $0012
	; source: library:/prog8lib/cx16/syslib.p8:168   &ubyte r9L  = $0014
	; source: library:/prog8lib/cx16/syslib.p8:169   &ubyte r10L = $0016
	; source: library:/prog8lib/cx16/syslib.p8:170   &ubyte r11L = $0018
	; source: library:/prog8lib/cx16/syslib.p8:171   &ubyte r12L = $001a
	; source: library:/prog8lib/cx16/syslib.p8:172   &ubyte r13L = $001c
	; source: library:/prog8lib/cx16/syslib.p8:173   &ubyte r14L = $001e
	; source: library:/prog8lib/cx16/syslib.p8:174   &ubyte r15L = $0020
	; source: library:/prog8lib/cx16/syslib.p8:176   &ubyte r0H  = $0003
	; source: library:/prog8lib/cx16/syslib.p8:177   &ubyte r1H  = $0005
	; source: library:/prog8lib/cx16/syslib.p8:178   &ubyte r2H  = $0007
	; source: library:/prog8lib/cx16/syslib.p8:179   &ubyte r3H  = $0009
	; source: library:/prog8lib/cx16/syslib.p8:180   &ubyte r4H  = $000b
	; source: library:/prog8lib/cx16/syslib.p8:181   &ubyte r5H  = $000d
	; source: library:/prog8lib/cx16/syslib.p8:182   &ubyte r6H  = $000f
	; source: library:/prog8lib/cx16/syslib.p8:183   &ubyte r7H  = $0011
	; source: library:/prog8lib/cx16/syslib.p8:184   &ubyte r8H  = $0013
	; source: library:/prog8lib/cx16/syslib.p8:185   &ubyte r9H  = $0015
	; source: library:/prog8lib/cx16/syslib.p8:186   &ubyte r10H = $0017
	; source: library:/prog8lib/cx16/syslib.p8:187   &ubyte r11H = $0019
	; source: library:/prog8lib/cx16/syslib.p8:188   &ubyte r12H = $001b
	; source: library:/prog8lib/cx16/syslib.p8:189   &ubyte r13H = $001d
	; source: library:/prog8lib/cx16/syslib.p8:190   &ubyte r14H = $001f
	; source: library:/prog8lib/cx16/syslib.p8:191   &ubyte r15H = $0021
	; source: library:/prog8lib/cx16/syslib.p8:193   &byte r0sL  = $0002
	; source: library:/prog8lib/cx16/syslib.p8:194   &byte r1sL  = $0004
	; source: library:/prog8lib/cx16/syslib.p8:195   &byte r2sL  = $0006
	; source: library:/prog8lib/cx16/syslib.p8:196   &byte r3sL  = $0008
	; source: library:/prog8lib/cx16/syslib.p8:197   &byte r4sL  = $000a
	; source: library:/prog8lib/cx16/syslib.p8:198   &byte r5sL  = $000c
	; source: library:/prog8lib/cx16/syslib.p8:199   &byte r6sL  = $000e
	; source: library:/prog8lib/cx16/syslib.p8:200   &byte r7sL  = $0010
	; source: library:/prog8lib/cx16/syslib.p8:201   &byte r8sL  = $0012
	; source: library:/prog8lib/cx16/syslib.p8:202   &byte r9sL  = $0014
	; source: library:/prog8lib/cx16/syslib.p8:203   &byte r10sL = $0016
	; source: library:/prog8lib/cx16/syslib.p8:204   &byte r11sL = $0018
	; source: library:/prog8lib/cx16/syslib.p8:205   &byte r12sL = $001a
	; source: library:/prog8lib/cx16/syslib.p8:206   &byte r13sL = $001c
	; source: library:/prog8lib/cx16/syslib.p8:207   &byte r14sL = $001e
	; source: library:/prog8lib/cx16/syslib.p8:208   &byte r15sL = $0020
	; source: library:/prog8lib/cx16/syslib.p8:210   &byte r0sH  = $0003
	; source: library:/prog8lib/cx16/syslib.p8:211   &byte r1sH  = $0005
	; source: library:/prog8lib/cx16/syslib.p8:212   &byte r2sH  = $0007
	; source: library:/prog8lib/cx16/syslib.p8:213   &byte r3sH  = $0009
	; source: library:/prog8lib/cx16/syslib.p8:214   &byte r4sH  = $000b
	; source: library:/prog8lib/cx16/syslib.p8:215   &byte r5sH  = $000d
	; source: library:/prog8lib/cx16/syslib.p8:216   &byte r6sH  = $000f
	; source: library:/prog8lib/cx16/syslib.p8:217   &byte r7sH  = $0011
	; source: library:/prog8lib/cx16/syslib.p8:218   &byte r8sH  = $0013
	; source: library:/prog8lib/cx16/syslib.p8:219   &byte r9sH  = $0015
	; source: library:/prog8lib/cx16/syslib.p8:220   &byte r10sH = $0017
	; source: library:/prog8lib/cx16/syslib.p8:221   &byte r11sH = $0019
	; source: library:/prog8lib/cx16/syslib.p8:222   &byte r12sH = $001b
	; source: library:/prog8lib/cx16/syslib.p8:223   &byte r13sH = $001d
	; source: library:/prog8lib/cx16/syslib.p8:224   &byte r14sH = $001f
	; source: library:/prog8lib/cx16/syslib.p8:225   &byte r15sH = $0021
	; source: library:/prog8lib/cx16/syslib.p8:229   const uword VERA_BASE       = $9F20
	; source: library:/prog8lib/cx16/syslib.p8:230   &ubyte  VERA_ADDR_L         = VERA_BASE + $0000
	; source: library:/prog8lib/cx16/syslib.p8:231   &ubyte  VERA_ADDR_M         = VERA_BASE + $0001
	; source: library:/prog8lib/cx16/syslib.p8:232   &ubyte  VERA_ADDR_H         = VERA_BASE + $0002
	; source: library:/prog8lib/cx16/syslib.p8:233   &ubyte  VERA_DATA0          = VERA_BASE + $0003
	; source: library:/prog8lib/cx16/syslib.p8:234   &ubyte  VERA_DATA1          = VERA_BASE + $0004
	; source: library:/prog8lib/cx16/syslib.p8:235   &ubyte  VERA_CTRL           = VERA_BASE + $0005
	; source: library:/prog8lib/cx16/syslib.p8:236   &ubyte  VERA_IEN            = VERA_BASE + $0006
	; source: library:/prog8lib/cx16/syslib.p8:237   &ubyte  VERA_ISR            = VERA_BASE + $0007
	; source: library:/prog8lib/cx16/syslib.p8:238   &ubyte  VERA_IRQ_LINE_L     = VERA_BASE + $0008
	; source: library:/prog8lib/cx16/syslib.p8:239   &ubyte  VERA_DC_VIDEO       = VERA_BASE + $0009 ; DCSEL= 0
	; source: library:/prog8lib/cx16/syslib.p8:240   &ubyte  VERA_DC_HSCALE      = VERA_BASE + $000A ; DCSEL= 0
	; source: library:/prog8lib/cx16/syslib.p8:241   &ubyte  VERA_DC_VSCALE      = VERA_BASE + $000B ; DCSEL= 0
	; source: library:/prog8lib/cx16/syslib.p8:242   &ubyte  VERA_DC_BORDER      = VERA_BASE + $000C ; DCSEL= 0
	; source: library:/prog8lib/cx16/syslib.p8:243   &ubyte  VERA_DC_HSTART      = VERA_BASE + $0009 ; DCSEL= 1
	; source: library:/prog8lib/cx16/syslib.p8:244   &ubyte  VERA_DC_HSTOP       = VERA_BASE + $000A ; DCSEL= 1
	; source: library:/prog8lib/cx16/syslib.p8:245   &ubyte  VERA_DC_VSTART      = VERA_BASE + $000B ; DCSEL= 1
	; source: library:/prog8lib/cx16/syslib.p8:246   &ubyte  VERA_DC_VSTOP       = VERA_BASE + $000C ; DCSEL= 1
	; source: library:/prog8lib/cx16/syslib.p8:247   &ubyte  VERA_DC_VER0        = VERA_BASE + $0009 ; DCSEL=63
	; source: library:/prog8lib/cx16/syslib.p8:248   &ubyte  VERA_DC_VER1        = VERA_BASE + $000A ; DCSEL=63
	; source: library:/prog8lib/cx16/syslib.p8:249   &ubyte  VERA_DC_VER2        = VERA_BASE + $000B ; DCSEL=63
	; source: library:/prog8lib/cx16/syslib.p8:250   &ubyte  VERA_DC_VER3        = VERA_BASE + $000C ; DCSEL=63
	; source: library:/prog8lib/cx16/syslib.p8:251   &ubyte  VERA_L0_CONFIG      = VERA_BASE + $000D
	; source: library:/prog8lib/cx16/syslib.p8:252   &ubyte  VERA_L0_MAPBASE     = VERA_BASE + $000E
	; source: library:/prog8lib/cx16/syslib.p8:253   &ubyte  VERA_L0_TILEBASE    = VERA_BASE + $000F
	; source: library:/prog8lib/cx16/syslib.p8:254   &ubyte  VERA_L0_HSCROLL_L   = VERA_BASE + $0010
	; source: library:/prog8lib/cx16/syslib.p8:255   &ubyte  VERA_L0_HSCROLL_H   = VERA_BASE + $0011
	; source: library:/prog8lib/cx16/syslib.p8:256   &ubyte  VERA_L0_VSCROLL_L   = VERA_BASE + $0012
	; source: library:/prog8lib/cx16/syslib.p8:257   &ubyte  VERA_L0_VSCROLL_H   = VERA_BASE + $0013
	; source: library:/prog8lib/cx16/syslib.p8:258   &ubyte  VERA_L1_CONFIG      = VERA_BASE + $0014
	; source: library:/prog8lib/cx16/syslib.p8:259   &ubyte  VERA_L1_MAPBASE     = VERA_BASE + $0015
	; source: library:/prog8lib/cx16/syslib.p8:260   &ubyte  VERA_L1_TILEBASE    = VERA_BASE + $0016
	; source: library:/prog8lib/cx16/syslib.p8:261   &ubyte  VERA_L1_HSCROLL_L   = VERA_BASE + $0017
	; source: library:/prog8lib/cx16/syslib.p8:262   &ubyte  VERA_L1_HSCROLL_H   = VERA_BASE + $0018
	; source: library:/prog8lib/cx16/syslib.p8:263   &ubyte  VERA_L1_VSCROLL_L   = VERA_BASE + $0019
	; source: library:/prog8lib/cx16/syslib.p8:264   &ubyte  VERA_L1_VSCROLL_H   = VERA_BASE + $001A
	; source: library:/prog8lib/cx16/syslib.p8:265   &ubyte  VERA_AUDIO_CTRL     = VERA_BASE + $001B
	; source: library:/prog8lib/cx16/syslib.p8:266   &ubyte  VERA_AUDIO_RATE     = VERA_BASE + $001C
	; source: library:/prog8lib/cx16/syslib.p8:267   &ubyte  VERA_AUDIO_DATA     = VERA_BASE + $001D
	; source: library:/prog8lib/cx16/syslib.p8:268   &ubyte  VERA_SPI_DATA       = VERA_BASE + $001E
	; source: library:/prog8lib/cx16/syslib.p8:269   &ubyte  VERA_SPI_CTRL       = VERA_BASE + $001F
	; source: library:/prog8lib/cx16/syslib.p8:272   &ubyte VERA_FX_CTRL         = VERA_BASE + $0009
	; source: library:/prog8lib/cx16/syslib.p8:273   &ubyte VERA_FX_MULT         = VERA_BASE + $000C
	; source: library:/prog8lib/cx16/syslib.p8:274   &ubyte VERA_FX_CACHE_L      = VERA_BASE + $0009
	; source: library:/prog8lib/cx16/syslib.p8:275   &ubyte VERA_FX_CACHE_M      = VERA_BASE + $000A
	; source: library:/prog8lib/cx16/syslib.p8:276   &ubyte VERA_FX_CACHE_H      = VERA_BASE + $000B
	; source: library:/prog8lib/cx16/syslib.p8:277   &ubyte VERA_FX_CACHE_U      = VERA_BASE + $000C
	; source: library:/prog8lib/cx16/syslib.p8:278   &ubyte VERA_FX_ACCUM_RESET  = VERA_BASE + $0009     ; (DCSEL=6)
	; source: library:/prog8lib/cx16/syslib.p8:287   const uword  VIA1_BASE   = $9f00                  ;VIA 6522 #1
	; source: library:/prog8lib/cx16/syslib.p8:288   &ubyte  via1prb    = VIA1_BASE + 0
	; source: library:/prog8lib/cx16/syslib.p8:289   &ubyte  via1pra    = VIA1_BASE + 1
	; source: library:/prog8lib/cx16/syslib.p8:290   &ubyte  via1ddrb   = VIA1_BASE + 2
	; source: library:/prog8lib/cx16/syslib.p8:291   &ubyte  via1ddra   = VIA1_BASE + 3
	; source: library:/prog8lib/cx16/syslib.p8:292   &ubyte  via1t1l    = VIA1_BASE + 4
	; source: library:/prog8lib/cx16/syslib.p8:293   &ubyte  via1t1h    = VIA1_BASE + 5
	; source: library:/prog8lib/cx16/syslib.p8:294   &ubyte  via1t1ll   = VIA1_BASE + 6
	; source: library:/prog8lib/cx16/syslib.p8:295   &ubyte  via1t1lh   = VIA1_BASE + 7
	; source: library:/prog8lib/cx16/syslib.p8:296   &ubyte  via1t2l    = VIA1_BASE + 8
	; source: library:/prog8lib/cx16/syslib.p8:297   &ubyte  via1t2h    = VIA1_BASE + 9
	; source: library:/prog8lib/cx16/syslib.p8:298   &ubyte  via1sr     = VIA1_BASE + 10
	; source: library:/prog8lib/cx16/syslib.p8:299   &ubyte  via1acr    = VIA1_BASE + 11
	; source: library:/prog8lib/cx16/syslib.p8:300   &ubyte  via1pcr    = VIA1_BASE + 12
	; source: library:/prog8lib/cx16/syslib.p8:301   &ubyte  via1ifr    = VIA1_BASE + 13
	; source: library:/prog8lib/cx16/syslib.p8:302   &ubyte  via1ier    = VIA1_BASE + 14
	; source: library:/prog8lib/cx16/syslib.p8:303   &ubyte  via1ora    = VIA1_BASE + 15
	; source: library:/prog8lib/cx16/syslib.p8:305   const uword  VIA2_BASE   = $9f10                  ;VIA 6522 #2
	; source: library:/prog8lib/cx16/syslib.p8:306   &ubyte  via2prb    = VIA2_BASE + 0
	; source: library:/prog8lib/cx16/syslib.p8:307   &ubyte  via2pra    = VIA2_BASE + 1
	; source: library:/prog8lib/cx16/syslib.p8:308   &ubyte  via2ddrb   = VIA2_BASE + 2
	; source: library:/prog8lib/cx16/syslib.p8:309   &ubyte  via2ddra   = VIA2_BASE + 3
	; source: library:/prog8lib/cx16/syslib.p8:310   &ubyte  via2t1l    = VIA2_BASE + 4
	; source: library:/prog8lib/cx16/syslib.p8:311   &ubyte  via2t1h    = VIA2_BASE + 5
	; source: library:/prog8lib/cx16/syslib.p8:312   &ubyte  via2t1ll   = VIA2_BASE + 6
	; source: library:/prog8lib/cx16/syslib.p8:313   &ubyte  via2t1lh   = VIA2_BASE + 7
	; source: library:/prog8lib/cx16/syslib.p8:314   &ubyte  via2t2l    = VIA2_BASE + 8
	; source: library:/prog8lib/cx16/syslib.p8:315   &ubyte  via2t2h    = VIA2_BASE + 9
	; source: library:/prog8lib/cx16/syslib.p8:316   &ubyte  via2sr     = VIA2_BASE + 10
	; source: library:/prog8lib/cx16/syslib.p8:317   &ubyte  via2acr    = VIA2_BASE + 11
	; source: library:/prog8lib/cx16/syslib.p8:318   &ubyte  via2pcr    = VIA2_BASE + 12
	; source: library:/prog8lib/cx16/syslib.p8:319   &ubyte  via2ifr    = VIA2_BASE + 13
	; source: library:/prog8lib/cx16/syslib.p8:320   &ubyte  via2ier    = VIA2_BASE + 14
	; source: library:/prog8lib/cx16/syslib.p8:321   &ubyte  via2ora    = VIA2_BASE + 15
	; source: library:/prog8lib/cx16/syslib.p8:324   &ubyte  YM_ADDRESS	= $9f40
	; source: library:/prog8lib/cx16/syslib.p8:325   &ubyte  YM_DATA	    = $9f41
	; source: library:/prog8lib/cx16/syslib.p8:327   const uword  extdev	= $9f60
	; source: library:/prog8lib/cx16/syslib.p8:88   %option no_symbol_prefixing
	; source: library:/prog8lib/cx16/syslib.p8:334   romsub $ff4a = CLOSE_ALL(ubyte device @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:335   romsub $ff59 = LKUPLA(ubyte la @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:336   romsub $ff5c = LKUPSA(ubyte sa @Y)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:337   romsub $ff5f = screen_mode(ubyte mode @A, bool getCurrent @Pc)  clobbers(X, Y) -> ubyte @A, bool @Pc        ; note: X,Y size result is not supported, use SCREEN or get_screen_mode routine for that

	; source: library:/prog8lib/cx16/syslib.p8:338   romsub $ff62 = screen_set_charset(ubyte charset @A, uword charsetptr @XY)  clobbers(A,X,Y)      ; incompatible with C128  dlchr()

	; source: library:/prog8lib/cx16/syslib.p8:340   romsub $ff6e = JSRFAR()  ; following word = address to call, byte after that=rom/ram bank it is in

	; source: library:/prog8lib/cx16/syslib.p8:341   romsub $ff74 = fetch(ubyte bank @X, ubyte index @Y)  clobbers(X) -> ubyte @A

	; source: library:/prog8lib/cx16/syslib.p8:342   romsub $ff77 = stash(ubyte data @A, ubyte bank @X, ubyte index @Y)  clobbers(X)

	; source: library:/prog8lib/cx16/syslib.p8:343   romsub $ff7d = PRIMM()

	; source: library:/prog8lib/cx16/syslib.p8:348   romsub $ff20 = GRAPH_init(uword vectors @R0)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:349   romsub $ff23 = GRAPH_clear()  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:350   romsub $ff26 = GRAPH_set_window(uword x @R0, uword y @R1, uword width @R2, uword height @R3)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:351   romsub $ff29 = GRAPH_set_colors(ubyte stroke @A, ubyte fill @X, ubyte background @Y)  clobbers (A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:352   romsub $ff2c = GRAPH_draw_line(uword x1 @R0, uword y1 @R1, uword x2 @R2, uword y2 @R3)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:353   romsub $ff2f = GRAPH_draw_rect(uword x @R0, uword y @R1, uword width @R2, uword height @R3, uword cornerradius @R4, bool fill @Pc)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:354   romsub $ff32 = GRAPH_move_rect(uword sx @R0, uword sy @R1, uword tx @R2, uword ty @R3, uword width @R4, uword height @R5)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:355   romsub $ff35 = GRAPH_draw_oval(uword x @R0, uword y @R1, uword width @R2, uword height @R3, bool fill @Pc)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:356   romsub $ff38 = GRAPH_draw_image(uword x @R0, uword y @R1, uword ptr @R2, uword width @R3, uword height @R4)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:357   romsub $ff3b = GRAPH_set_font(uword fontptr @R0)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:358   romsub $ff3e = GRAPH_get_char_size(ubyte baseline @A, ubyte width @X, ubyte height_or_style @Y, bool is_control @Pc)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:359   romsub $ff41 = GRAPH_put_char(uword x @R0, uword y @R1, ubyte character @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:360   romsub $ff41 = GRAPH_put_next_char(ubyte character @A)  clobbers(A,X,Y)     ; alias for the routine above that doesn't reset the position of the initial character

	; source: library:/prog8lib/cx16/syslib.p8:363   romsub $fef6 = FB_init()  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:364   romsub $fef9 = FB_get_info()  clobbers(X,Y) -> byte @A, uword @R0, uword @R1    ; width=r0, height=r1

	; source: library:/prog8lib/cx16/syslib.p8:365   romsub $fefc = FB_set_palette(uword pointer @R0, ubyte index @A, ubyte colorcount @X)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:366   romsub $feff = FB_cursor_position(uword x @R0, uword y @R1)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:367   romsub $feff = FB_cursor_position2()  clobbers(A,X,Y)           ;  alias for the previous routine, but avoiding having to respecify both x and y every time

	; source: library:/prog8lib/cx16/syslib.p8:368   romsub $ff02 = FB_cursor_next_line(uword x @R0)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:369   romsub $ff05 = FB_get_pixel()  clobbers(X,Y) -> ubyte @A

	; source: library:/prog8lib/cx16/syslib.p8:370   romsub $ff08 = FB_get_pixels(uword pointer @R0, uword count @R1)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:371   romsub $ff0b = FB_set_pixel(ubyte color @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:372   romsub $ff0e = FB_set_pixels(uword pointer @R0, uword count @R1)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:373   romsub $ff11 = FB_set_8_pixels(ubyte pattern @A, ubyte color @X)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:374   romsub $ff14 = FB_set_8_pixels_opaque(ubyte pattern @R0, ubyte mask @A, ubyte color1 @X, ubyte color2 @Y)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:375   romsub $ff17 = FB_fill_pixels(uword count @R0, uword pstep @R1, ubyte color @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:376   romsub $ff1a = FB_filter_pixels(uword pointer @ R0, uword count @R1)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:377   romsub $ff1d = FB_move_pixels(uword sx @R0, uword sy @R1, uword tx @R2, uword ty @R3, uword count @R4)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:380   romsub $FEBA = BSAVE(ubyte zp_startaddr @ A, uword endaddr @ XY) clobbers (X, Y) -> bool @ Pc, ubyte @ A      ; like cbm.SAVE, but omits the 2-byte prg header

	; source: library:/prog8lib/cx16/syslib.p8:381   romsub $fec6 = i2c_read_byte(ubyte device @X, ubyte offset @Y) clobbers (X,Y) -> ubyte @A, bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:382   romsub $fec9 = i2c_write_byte(ubyte device @X, ubyte offset @Y, ubyte data @A) clobbers (A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:383   romsub $fef0 = sprite_set_image(uword pixels @R0, uword mask @R1, ubyte bpp @R2, ubyte number @A, ubyte width @X, ubyte height @Y, bool apply_mask @Pc)  clobbers(A,X,Y) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:384   romsub $fef3 = sprite_set_position(uword x @R0, uword y @R1, ubyte number @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:385   romsub $fee4 = memory_fill(uword address @R0, uword num_bytes @R1, ubyte value @A)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:386   romsub $fee7 = memory_copy(uword source @R0, uword target @R1, uword num_bytes @R2)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:387   romsub $feea = memory_crc(uword address @R0, uword num_bytes @R1)  clobbers(A,X,Y) -> uword @R2

	; source: library:/prog8lib/cx16/syslib.p8:388   romsub $feed = memory_decompress(uword input @R0, uword output @R1)  clobbers(A,X,Y) -> uword @R1       ; last address +1 is result in R1

	; source: library:/prog8lib/cx16/syslib.p8:389   romsub $fedb = console_init(uword x @R0, uword y @R1, uword width @R2, uword height @R3)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:390   romsub $fede = console_put_char(ubyte character @A, bool wrapping @Pc)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:391   romsub $fee1 = console_get_char()  clobbers(X,Y) -> ubyte @A

	; source: library:/prog8lib/cx16/syslib.p8:392   romsub $fed8 = console_put_image(uword pointer @R0, uword width @R1, uword height @R2)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:393   romsub $fed5 = console_set_paging_message(uword msgptr @R0)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:394   romsub $fecf = entropy_get() -> ubyte @A, ubyte @X, ubyte @Y

	; source: library:/prog8lib/cx16/syslib.p8:395   romsub $fecc = monitor()  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:397   romsub $ff44 = MACPTR(ubyte length @A, uword buffer @XY, bool dontAdvance @Pc)  clobbers(A) -> bool @Pc, uword @XY

	; source: library:/prog8lib/cx16/syslib.p8:398   romsub $feb1 = MCIOUT(ubyte length @A, uword buffer @XY, bool dontAdvance @Pc)  clobbers(A) -> bool @Pc, uword @XY

	; source: library:/prog8lib/cx16/syslib.p8:399   romsub $ff47 = enter_basic(bool cold_or_warm @Pc)  clobbers(A,X,Y)

	; source: library:/prog8lib/cx16/syslib.p8:400   romsub $ff4d = clock_set_date_time(uword yearmonth @R0, uword dayhours @R1, uword minsecs @R2, ubyte jiffies @R3)  clobbers(A, X, Y)

	; source: library:/prog8lib/cx16/syslib.p8:401   romsub $ff50 = clock_get_date_time()  clobbers(A, X, Y)  -> uword @R0, uword @R1, uword @R2, ubyte @R3   ; result registers see clock_set_date_time()

	; source: library:/prog8lib/cx16/syslib.p8:405   romsub $febd = kbdbuf_peek() -> ubyte @A, ubyte @X     ; key in A, queue length in X

	; source: library:/prog8lib/cx16/syslib.p8:406   romsub $febd = kbdbuf_peek2() -> uword @AX             ; alternative to above to not have the hassle to deal with multiple return values

	; source: library:/prog8lib/cx16/syslib.p8:407   romsub $fec0 = kbdbuf_get_modifiers() -> ubyte @A

	; source: library:/prog8lib/cx16/syslib.p8:408   romsub $fec3 = kbdbuf_put(ubyte key @A) clobbers(X)

	; source: library:/prog8lib/cx16/syslib.p8:409   romsub $fed2 = keymap(uword identifier @XY, bool read @Pc) -> bool @Pc

	; source: library:/prog8lib/cx16/syslib.p8:410   romsub $ff68 = mouse_config(ubyte shape @A, ubyte resX @X, ubyte resY @Y)  clobbers (A, X, Y)

	; source: library:/prog8lib/cx16/syslib.p8:411   romsub $ff6b = mouse_get(ubyte zpdataptr @X) -> ubyte @A

	; source: library:/prog8lib/cx16/syslib.p8:412   romsub $ff71 = mouse_scan()  clobbers(A, X, Y)

	; source: library:/prog8lib/cx16/syslib.p8:413   romsub $ff53 = joystick_scan()  clobbers(A, X, Y)

	; source: library:/prog8lib/cx16/syslib.p8:414   romsub $ff56 = joystick_get(ubyte joynr @A) -> ubyte @A, ubyte @X, ubyte @Y

	; source: library:/prog8lib/cx16/syslib.p8:415   romsub $ff56 = joystick_get2(ubyte joynr @A) clobbers(Y) -> uword @AX   ; alternative to above to not have the hassle to deal with multiple return values

	; source: library:/prog8lib/cx16/syslib.p8:418   romsub $C04B = psg_init() clobbers(A,X,Y)                              ; (re)init Vera PSG

	; source: library:/prog8lib/cx16/syslib.p8:419   romsub $C063 = ym_init() clobbers(A,X,Y) -> bool @Pc                   ; (re)init YM chip

	; source: library:/prog8lib/cx16/syslib.p8:420   romsub $C066 = ym_loaddefpatches() clobbers(A,X,Y) -> bool @Pc         ; load default YM patches

	; source: library:/prog8lib/cx16/syslib.p8:421   romsub $C09F = audio_init() clobbers(A,X,Y) -> bool @Pc                ; (re)initialize both vera PSG and YM audio chips

	; source: library:/prog8lib/cx16/syslib.p8:425   asmsub set_screen_mode(ubyte mode @A) clobbers(A,X,Y) -> bool @Pc {

set_screen_mode	.proc
	; source: library:/prog8lib/cx16/syslib.p8:427   %asm {{
        clc
        jmp  screen_mode
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:433   asmsub get_screen_mode() -> byte @A, byte @X, byte @Y {

get_screen_mode	.proc
	; source: library:/prog8lib/cx16/syslib.p8:438   %asm {{
        sec
        jmp  screen_mode
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:444   asmsub kbdbuf_clear() {

kbdbuf_clear	.proc
	; source: library:/prog8lib/cx16/syslib.p8:446   %asm {{
-       jsr  cbm.GETIN
        bne  -
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:453   asmsub mouse_config2(ubyte shape @A) clobbers (A, X, Y) {

mouse_config2	.proc
	; source: library:/prog8lib/cx16/syslib.p8:455   %asm {{
        pha                         ; save shape
        sec
        jsr  cx16.screen_mode       ; set current screen mode and res in A, X, Y
        pla                         ; get shape back
        jmp  cx16.mouse_config
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:464   asmsub mouse_pos() clobbers(X) -> ubyte @A {

mouse_pos	.proc
	; source: library:/prog8lib/cx16/syslib.p8:467   %asm {{
        ldx  #cx16.r0
        jmp  cx16.mouse_get
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:479   inline asmsub rombank(ubyte bank @A) {
	; source: library:/prog8lib/cx16/syslib.p8:486   inline asmsub rambank(ubyte bank @A) {
	; source: library:/prog8lib/cx16/syslib.p8:493   inline asmsub getrombank() -> ubyte @A {
	; source: library:/prog8lib/cx16/syslib.p8:500   inline asmsub getrambank() -> ubyte @A {
	; source: library:/prog8lib/cx16/syslib.p8:507   asmsub numbanks() clobbers(X) -> uword @AY {

numbanks	.proc
	; source: library:/prog8lib/cx16/syslib.p8:514   %asm {{
        sec
        jsr  cbm.MEMTOP
        ldy  #0
        cmp  #0
        bne  +
        iny
+       rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:525   asmsub vpeek(ubyte bank @A, uword address @XY) -> ubyte @A {

vpeek	.proc
	; source: library:/prog8lib/cx16/syslib.p8:528   %asm {{
                pha
                lda  cx16.VERA_CTRL
                ora  #1
                sta  cx16.VERA_CTRL
                pla
                and  #1
                sta  cx16.VERA_ADDR_H
                sty  cx16.VERA_ADDR_M
                stx  cx16.VERA_ADDR_L
                lda  cx16.VERA_DATA1
                rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:543   asmsub vaddr(ubyte bank @A, uword address @R0, ubyte addrsel @R1, byte autoIncrOrDecrByOne @Y) clobbers(A) {

vaddr	.proc
	; source: library:/prog8lib/cx16/syslib.p8:547   %asm {{
            and  #1
            pha
            lda  cx16.r1
            and  #1
            sta  cx16.VERA_CTRL
            lda  cx16.r0
            sta  cx16.VERA_ADDR_L
            lda  cx16.r0+1
            sta  cx16.VERA_ADDR_M
            pla
            cpy  #0
            bmi  ++
            beq  +
            ora  #%00010000
+           sta  cx16.VERA_ADDR_H
            rts
+           ora  #%00011000
            sta  cx16.VERA_ADDR_H
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:570   asmsub vaddr_clone(ubyte port @A) clobbers (A,X,Y) {

vaddr_clone	.proc
	; source: library:/prog8lib/cx16/syslib.p8:573   %asm {{
        sta  VERA_CTRL
        ldx  VERA_ADDR_L
        ldy  VERA_ADDR_H
        phy
        ldy  VERA_ADDR_M
        eor  #1
        sta  VERA_CTRL
        stx  VERA_ADDR_L
        sty  VERA_ADDR_M
        ply
        sty  VERA_ADDR_H
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:589   asmsub vaddr_autoincr(ubyte bank @A, uword address @R0, ubyte addrsel @R1, uword autoIncrAmount @R2) clobbers(A,Y) {

vaddr_autoincr	.proc
	; source: library:/prog8lib/cx16/syslib.p8:593   %asm {{
            jsr  _setup
            lda  cx16.r2H
            ora  cx16.r2L
            beq  +
            jsr  _determine_incr_bits
+           ora  P8ZP_SCRATCH_REG
            sta  cx16.VERA_ADDR_H
            rts

_setup      and  #1
            sta  P8ZP_SCRATCH_REG
            lda  cx16.r1
            and  #1
            sta  cx16.VERA_CTRL
            lda  cx16.r0
            sta  cx16.VERA_ADDR_L
            lda  cx16.r0+1
            sta  cx16.VERA_ADDR_M
            rts

_determine_incr_bits
            lda  cx16.r2H
            bne  _large
            lda  cx16.r2L
            ldy  #13
-           cmp  _strides_lsb,y
            beq  +
            dey
            bpl  -
+           tya
            asl  a
            asl  a
            asl  a
            asl  a
            rts
_large      ora  cx16.r2L
            cmp  #1         ; 256
            bne  +
            lda  #9<<4
            rts
+           cmp  #2         ; 512
            bne  +
            lda  #10<<4
            rts
+           cmp  #65        ; 320
            bne  +
            lda  #14<<4
            rts
+           cmp  #130       ; 640
            bne  +
            lda  #15<<4
            rts
+           lda  #0
            rts
_strides_lsb    .byte   0,1,2,4,8,16,32,64,128,255,255,40,80,160,255,255
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:652   asmsub vaddr_autodecr(ubyte bank @A, uword address @R0, ubyte addrsel @R1, uword autoDecrAmount @R2) clobbers(A,Y) {

vaddr_autodecr	.proc
	; source: library:/prog8lib/cx16/syslib.p8:656   %asm {{
            jsr  vaddr_autoincr._setup
            lda  cx16.r2H
            ora  cx16.r2L
            beq  +
            jsr  vaddr_autoincr._determine_incr_bits
            ora  #%00001000         ; autodecrement
+           ora  P8ZP_SCRATCH_REG
            sta  cx16.VERA_ADDR_H
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:669   asmsub vpoke(ubyte bank @A, uword address @R0, ubyte value @Y) clobbers(A) {

vpoke	.proc
	; source: library:/prog8lib/cx16/syslib.p8:672   %asm {{
        stz  cx16.VERA_CTRL
        and  #1
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        sty  cx16.VERA_DATA0
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:685   asmsub vpoke_or(ubyte bank @A, uword address @R0, ubyte value @Y) clobbers (A) {

vpoke_or	.proc
	; source: library:/prog8lib/cx16/syslib.p8:688   %asm {{
        stz  cx16.VERA_CTRL
        and  #1
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        tya
        ora  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:703   asmsub vpoke_and(ubyte bank @A, uword address @R0, ubyte value @Y) clobbers(A) {

vpoke_and	.proc
	; source: library:/prog8lib/cx16/syslib.p8:706   %asm {{
        stz  cx16.VERA_CTRL
        and  #1
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        tya
        and  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:721   asmsub vpoke_xor(ubyte bank @A, uword address @R0, ubyte value @Y) clobbers (A) {

vpoke_xor	.proc
	; source: library:/prog8lib/cx16/syslib.p8:724   %asm {{
        stz  cx16.VERA_CTRL
        and  #1
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        tya
        eor  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:739   asmsub vpoke_mask(ubyte bank @A, uword address @R0, ubyte mask @X, ubyte value @Y) clobbers (A) {

vpoke_mask	.proc
	; source: library:/prog8lib/cx16/syslib.p8:742   %asm {{
        sty  P8ZP_SCRATCH_B1
        stz  cx16.VERA_CTRL
        and  #1
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        txa
        and  cx16.VERA_DATA0
        ora  P8ZP_SCRATCH_B1
        sta  cx16.VERA_DATA0
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:759   asmsub save_virtual_registers() clobbers(A,Y) {

save_virtual_registers	.proc
	; source: library:/prog8lib/cx16/syslib.p8:760   %asm {{
        ldy  #31
-       lda  cx16.r0,y
        sta  _cx16_vreg_storage,y
        dey
        bpl  -
        rts

_cx16_vreg_storage
        .word 0,0,0,0,0,0,0,0
        .word 0,0,0,0,0,0,0,0
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:774   asmsub restore_virtual_registers() clobbers(A,Y) {

restore_virtual_registers	.proc
	; source: library:/prog8lib/cx16/syslib.p8:775   %asm {{
        ldy  #31
-       lda  save_virtual_registers._cx16_vreg_storage,y
        sta  cx16.r0,y
        dey
        bpl  -
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:786   asmsub save_vera_context() clobbers(A) {

save_vera_context	.proc
	; source: library:/prog8lib/cx16/syslib.p8:788   %asm {{
        ; note cannot store this on cpu hardware stack because this gets called as a subroutine
        lda  cx16.VERA_ADDR_L
        sta  _vera_storage
        lda  cx16.VERA_ADDR_M
        sta  _vera_storage+1
        lda  cx16.VERA_ADDR_H
        sta  _vera_storage+2
        lda  cx16.VERA_CTRL
        sta  _vera_storage+3
        eor  #1
        sta  _vera_storage+7
        sta  cx16.VERA_CTRL
        lda  cx16.VERA_ADDR_L
        sta  _vera_storage+4
        lda  cx16.VERA_ADDR_M
        sta  _vera_storage+5
        lda  cx16.VERA_ADDR_H
        sta  _vera_storage+6
        rts
_vera_storage:  .byte 0,0,0,0,0,0,0,0
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:812   asmsub restore_vera_context() clobbers(A) {

restore_vera_context	.proc
	; source: library:/prog8lib/cx16/syslib.p8:814   %asm {{
        lda  cx16.save_vera_context._vera_storage+7
        sta  cx16.VERA_CTRL
        lda  cx16.save_vera_context._vera_storage+6
        sta  cx16.VERA_ADDR_H
        lda  cx16.save_vera_context._vera_storage+5
        sta  cx16.VERA_ADDR_M
        lda  cx16.save_vera_context._vera_storage+4
        sta  cx16.VERA_ADDR_L
        lda  cx16.save_vera_context._vera_storage+3
        sta  cx16.VERA_CTRL
        lda  cx16.save_vera_context._vera_storage+2
        sta  cx16.VERA_ADDR_H
        lda  cx16.save_vera_context._vera_storage+1
        sta  cx16.VERA_ADDR_M
        lda  cx16.save_vera_context._vera_storage+0
        sta  cx16.VERA_ADDR_L
        rts
	.pend
	.pend

; ---- block: 'sys' ----
sys	.proc
	; source: library:/prog8lib/cx16/syslib.p8:837   sys {
	target = $10


	; source: library:/prog8lib/cx16/syslib.p8:842   const ubyte target = 16         ;  compilation target specifier.  64 = C64,  128 = C128,  16 = CommanderX16.
	; source: library:/prog8lib/cx16/syslib.p8:840   %option no_symbol_prefixing
	; source: library:/prog8lib/cx16/syslib.p8:844   asmsub  init_system()  {

init_system	.proc
	; source: library:/prog8lib/cx16/syslib.p8:847   %asm {{
        sei
        lda  #0
        tax
        tay
        jsr  cx16.mouse_config  ; disable mouse
        cld
        lda  cx16.VERA_DC_VIDEO
        and  #%00000111 ; retain chroma + output mode
        sta  P8ZP_SCRATCH_REG
        lda  #$0a
        sta  $01        ; rom bank 10 (audio)
        jsr  cx16.audio_init ; silence
        stz  $01        ; rom bank 0 (kernal)
        jsr  cbm.IOINIT
        jsr  cbm.RESTOR
        jsr  cbm.CINT
        lda  cx16.VERA_DC_VIDEO
        and  #%11111000
        ora  P8ZP_SCRATCH_REG
        sta  cx16.VERA_DC_VIDEO  ; restore old output mode
        lda  #$90       ; black
        jsr  cbm.CHROUT
        lda  #1
        jsr  cbm.CHROUT ; swap fg/bg
        lda  #$9e       ; yellow
        jsr  cbm.CHROUT
        lda  #147       ; clear screen
        jsr  cbm.CHROUT
        lda  #PROG8_VARSHIGH_RAMBANK
        sta  $00    ; select ram bank
        lda  #0
        tax
        tay
        clc
        clv
        cli
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:888   asmsub  init_system_phase2()  {

init_system_phase2	.proc
	; source: library:/prog8lib/cx16/syslib.p8:889   %asm {{
        sei
        lda  cx16.CINV
        sta  restore_irq._orig_irqvec
        lda  cx16.CINV+1
        sta  restore_irq._orig_irqvec+1
        lda  #PROG8_VARSHIGH_RAMBANK
        sta  $00    ; select ram bank
        cli
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:902   asmsub  cleanup_at_exit() {

cleanup_at_exit	.proc
	; source: library:/prog8lib/cx16/syslib.p8:904   %asm {{
        lda  #1
        sta  $00        ; ram bank 1
        lda  #4
        sta  $01        ; rom bank 4 (basic)
        stz  $2d        ; hack to reset machine code monitor bank to 0
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:914   asmsub  set_irq(uword handler @AY, bool useKernal @Pc) clobbers(A)  {

set_irq	.proc
	; source: library:/prog8lib/cx16/syslib.p8:915   %asm {{
	        sta  _modified+1
	        sty  _modified+2
	        lda  #0
	        rol  a
	        sta  _use_kernal
		sei
		lda  #<_irq_handler
		sta  cx16.CINV
		lda  #>_irq_handler
		sta  cx16.CINV+1
                lda  cx16.VERA_IEN
                ora  #%00000001     ; enable the vsync irq
                sta  cx16.VERA_IEN
		cli
		rts

_irq_handler    jsr  _irq_handler_init
_modified	jsr  $ffff                      ; modified
		jsr  _irq_handler_end
		lda  _use_kernal
		bne  +
		; end irq processing - don't use kernal's irq handling
		lda  #1
		sta  cx16.VERA_ISR      ; clear Vera Vsync irq status
		ply
		plx
		pla
		rti
+		jmp  (restore_irq._orig_irqvec)   ; continue with normal kernal irq routine

_use_kernal     .byte  0

_irq_handler_init
		; save all zp scratch registers as these might be clobbered by the irq routine
		lda  P8ZP_SCRATCH_B1
		sta  IRQ_SCRATCH_ZPB1
		lda  P8ZP_SCRATCH_REG
		sta  IRQ_SCRATCH_ZPREG
		lda  P8ZP_SCRATCH_W1
		sta  IRQ_SCRATCH_ZPWORD1
		lda  P8ZP_SCRATCH_W1+1
		sta  IRQ_SCRATCH_ZPWORD1+1
		lda  P8ZP_SCRATCH_W2
		sta  IRQ_SCRATCH_ZPWORD2
		lda  P8ZP_SCRATCH_W2+1
		sta  IRQ_SCRATCH_ZPWORD2+1
		cld
		rts

_irq_handler_end
		; restore all zp scratch registers
		lda  IRQ_SCRATCH_ZPB1
		sta  P8ZP_SCRATCH_B1
		lda  IRQ_SCRATCH_ZPREG
		sta  P8ZP_SCRATCH_REG
		lda  IRQ_SCRATCH_ZPWORD1
		sta  P8ZP_SCRATCH_W1
		lda  IRQ_SCRATCH_ZPWORD1+1
		sta  P8ZP_SCRATCH_W1+1
		lda  IRQ_SCRATCH_ZPWORD2
		sta  P8ZP_SCRATCH_W2
		lda  IRQ_SCRATCH_ZPWORD2+1
		sta  P8ZP_SCRATCH_W2+1
		rts

IRQ_SCRATCH_ZPB1	.byte  0
IRQ_SCRATCH_ZPREG	.byte  0
IRQ_SCRATCH_ZPWORD1	.word  0
IRQ_SCRATCH_ZPWORD2	.word  0
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:989   asmsub  restore_irq() clobbers(A) {

restore_irq	.proc
	; source: library:/prog8lib/cx16/syslib.p8:990   %asm {{
	    sei
	    lda  _orig_irqvec
	    sta  cx16.CINV
	    lda  _orig_irqvec+1
	    sta  cx16.CINV+1
	    lda  cx16.VERA_IEN
	    and  #%11110000     ; disable all Vera IRQs
	    ora  #%00000001     ; enable only the vsync Irq
	    sta  cx16.VERA_IEN
	    cli
	    rts
_orig_irqvec    .word  0
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1006   asmsub  set_rasterirq(uword handler @AY, uword rasterpos @R0) clobbers(A) {

set_rasterirq	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1007   %asm {{
            sta  _modified+1
            sty  _modified+2
            lda  cx16.r0
            ldy  cx16.r0+1
            sei
            lda  cx16.VERA_IEN
            and  #%11110000     ; clear other IRQs
            ora  #%00000010     ; enable the line (raster) irq
            sta  cx16.VERA_IEN
            lda  cx16.r0
            ldy  cx16.r0+1
            jsr  set_rasterline
            lda  #<_raster_irq_handler
            sta  cx16.CINV
            lda  #>_raster_irq_handler
            sta  cx16.CINV+1
            cli
            rts

_raster_irq_handler
            jsr  set_irq._irq_handler_init
_modified   jsr  $ffff                      ; modified
            jsr  set_irq._irq_handler_end
            ; end irq processing - don't use kernal's irq handling
            lda  cx16.VERA_ISR
            ora  #%00000010
            sta  cx16.VERA_ISR      ; clear Vera line irq status
            ply
            plx
            pla
            rti
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1042   asmsub  set_rasterline(uword line @AY) {

set_rasterline	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1043   %asm {{
        sta  cx16.VERA_IRQ_LINE_L
        lda  cx16.VERA_IEN
        and  #%01111111
        sta  cx16.VERA_IEN
        tya
        lsr  a
        ror  a
        and  #%10000000
        ora  cx16.VERA_IEN
        sta  cx16.VERA_IEN
        rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1058   asmsub reset_system() {

reset_system	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1061   %asm {{
            sei
            ldx #$42
            ldy #2
            lda #0
            jsr  cx16.i2c_write_byte
            bra  *
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1081   asmsub wait(uword jiffies @AY) clobbers(X) {

wait	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1085   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1

_loop       lda  P8ZP_SCRATCH_W1
            ora  P8ZP_SCRATCH_W1+1
            bne  +
            rts

+           sei
            jsr  cbm.RDTIM
            cli
            sta  P8ZP_SCRATCH_B1
-           sei
            jsr  cbm.RDTIM
            cli
            cmp  P8ZP_SCRATCH_B1
            beq  -

            lda  P8ZP_SCRATCH_W1
            bne  +
            dec  P8ZP_SCRATCH_W1+1
+           dec  P8ZP_SCRATCH_W1
            bra  _loop
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1112   inline asmsub waitvsync()  {
	; source: library:/prog8lib/cx16/syslib.p8:1121   asmsub internal_stringcopy(uword source @R0, uword target @AY) clobbers (A,Y) {

internal_stringcopy	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1123   %asm {{
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1132   asmsub memcopy(uword source @R0, uword target @R1, uword count @AY) clobbers(A,X,Y) {

memcopy	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1138   %asm {{
            cpy  #0
            bne  _longcopy

            ; copy <= 255 bytes
            tay
            bne  _copyshort
            rts     ; nothing to copy

_copyshort
            ; decrease source and target pointers so we can simply index by Y
            lda  cx16.r0
            bne  +
            dec  cx16.r0+1
+           dec  cx16.r0
            lda  cx16.r1
            bne  +
            dec  cx16.r1+1
+           dec  cx16.r1

-           lda  (cx16.r0),y
            sta  (cx16.r1),y
            dey
            bne  -
            rts

_longcopy
            pha                         ; lsb(count) = remainder in last page
            tya
            tax                         ; x = num pages (1+)
            ldy  #0
-           lda  (cx16.r0),y
            sta  (cx16.r1),y
            iny
            bne  -
            inc  cx16.r0+1
            inc  cx16.r1+1
            dex
            bne  -
            ply
            bne  _copyshort
            rts
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1183   asmsub memset(uword mem @R0, uword numbytes @R1, ubyte value @A) clobbers(A,X,Y) {

memset	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1184   %asm {{
            ldy  cx16.r0
            sty  P8ZP_SCRATCH_W1
            ldy  cx16.r0+1
            sty  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            ldy  cx16.r1+1
            jmp  prog8_lib.memset
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1195   asmsub memsetw(uword mem @R0, uword numwords @R1, uword value @AY) clobbers (A,X,Y) {

memsetw	.proc
	; source: library:/prog8lib/cx16/syslib.p8:1196   %asm {{
            ldx  cx16.r0
            stx  P8ZP_SCRATCH_W1
            ldx  cx16.r0+1
            stx  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            stx  P8ZP_SCRATCH_W2
            ldx  cx16.r1+1
            stx  P8ZP_SCRATCH_W2+1
            jmp  prog8_lib.memsetw
	.pend
	; source: library:/prog8lib/cx16/syslib.p8:1209   inline asmsub read_flags() -> ubyte @A {
	; source: library:/prog8lib/cx16/syslib.p8:1216   inline asmsub clear_carry() {
	; source: library:/prog8lib/cx16/syslib.p8:1222   inline asmsub set_carry() {
	; source: library:/prog8lib/cx16/syslib.p8:1228   inline asmsub clear_irqd() {
	; source: library:/prog8lib/cx16/syslib.p8:1234   inline asmsub set_irqd() {
	; source: library:/prog8lib/cx16/syslib.p8:1240   inline asmsub irqsafe_set_irqd() {
	; source: library:/prog8lib/cx16/syslib.p8:1247   inline asmsub irqsafe_clear_irqd() {
	; source: library:/prog8lib/cx16/syslib.p8:1253   inline asmsub exit(ubyte returnvalue @A) {
	; source: library:/prog8lib/cx16/syslib.p8:1263   inline asmsub progend() -> uword @AY {
	.pend

; ---- block: 'conv' ----
conv	.proc
	; source: library:/prog8lib/conv.p8:3   conv {

; non-zeropage variables
string_out	; PETSCII:"????????????????"
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $00

	; source: library:/prog8lib/conv.p8:9   str  @shared string_out = "????????????????"       ; result buffer for the string conversion routines
	; source: library:/prog8lib/conv.p8:5   %option no_symbol_prefixing
	; source: library:/prog8lib/conv.p8:11   asmsub  str_ub0  (ubyte value @ A) clobbers(A,X,Y)  {

str_ub0	.proc
	; source: library:/prog8lib/conv.p8:13   %asm {{
            jsr  conv.ubyte2decimal
            sty  string_out
            sta  string_out+1
            stx  string_out+2
            lda  #0
            sta  string_out+3
            rts
	.pend
	; source: library:/prog8lib/conv.p8:24   asmsub  str_ub  (ubyte value @ A) clobbers(A,X,Y)  {

str_ub	.proc
	; source: library:/prog8lib/conv.p8:26   %asm {{
		ldy  #0
		sty  P8ZP_SCRATCH_B1
		jsr  conv.ubyte2decimal
_output_byte_digits
                ; hundreds?
		cpy  #'0'
		beq  +
		pha
		tya
		ldy  P8ZP_SCRATCH_B1
		sta  string_out,y
		pla
		inc  P8ZP_SCRATCH_B1
		; tens?
+		ldy  P8ZP_SCRATCH_B1
                cmp  #'0'
		beq  +
		sta  string_out,y
		iny
+               ; ones.
                txa
                sta  string_out,y
                iny
                lda  #0
                sta  string_out,y
                rts
	.pend
	; source: library:/prog8lib/conv.p8:56   asmsub  str_b  (byte value @ A) clobbers(A,X,Y)  {

str_b	.proc
	; source: library:/prog8lib/conv.p8:58   %asm {{
            ldy  #0
            sty  P8ZP_SCRATCH_B1
            cmp  #0
            bpl  +
            pha
            lda  #'-'
            sta  string_out
            inc  P8ZP_SCRATCH_B1
            pla
+	    jsr  conv.byte2decimal
            bra  str_ub._output_byte_digits
	.pend
	; source: library:/prog8lib/conv.p8:73   asmsub  str_ubhex  (ubyte value @ A) clobbers(A,X,Y)  {

str_ubhex	.proc
	; source: library:/prog8lib/conv.p8:75   %asm {{
            jsr  conv.ubyte2hex
            sta  string_out
            sty  string_out+1
            lda  #0
            sta  string_out+2
            rts
	.pend
	; source: library:/prog8lib/conv.p8:85   asmsub  str_ubbin  (ubyte value @ A) clobbers(A,X,Y)  {

str_ubbin	.proc
	; source: library:/prog8lib/conv.p8:87   %asm {{
	    sta  P8ZP_SCRATCH_B1
	    ldy  #0
	    sty  string_out+8
	    ldy  #7
-	    lsr  P8ZP_SCRATCH_B1
            bcc  +
            lda  #'1'
            bne  _digit
+           lda  #'0'
_digit      sta  string_out,y
            dey
	    bpl  -
	    rts
	.pend
	; source: library:/prog8lib/conv.p8:104   asmsub  str_uwbin  (uword value @ AY) clobbers(A,X,Y)  {

str_uwbin	.proc
	; source: library:/prog8lib/conv.p8:106   %asm {{
	    sta  P8ZP_SCRATCH_REG
	    tya
	    jsr  str_ubbin
	    ldy  #0
	    sty  string_out+16
	    ldy  #7
-	    lsr  P8ZP_SCRATCH_REG
            bcc  +
            lda  #'1'
            bne  _digit
+           lda  #'0'
_digit      sta  string_out+8,y
            dey
	    bpl  -
	    rts
	.pend
	; source: library:/prog8lib/conv.p8:125   asmsub  str_uwhex  (uword value @ AY) clobbers(A,Y)  {

str_uwhex	.proc
	; source: library:/prog8lib/conv.p8:127   %asm {{
            pha
            tya
            jsr  conv.ubyte2hex
            sta  string_out
            sty  string_out+1
            pla
            jsr  conv.ubyte2hex
            sta  string_out+2
            sty  string_out+3
            lda  #0
            sta  string_out+4
            rts
	.pend
	; source: library:/prog8lib/conv.p8:143   asmsub  str_uw0  (uword value @ AY) clobbers(A,X,Y)  {

str_uw0	.proc
	; source: library:/prog8lib/conv.p8:145   %asm {{
	    jsr  conv.uword2decimal
	    ldy  #0
-           lda  conv.uword2decimal.decTenThousands,y
            sta  string_out,y
            beq  +
            iny
            bne  -
+	    rts
	.pend
	; source: library:/prog8lib/conv.p8:157   asmsub  str_uw  (uword value @ AY) clobbers(A,X,Y)  {

str_uw	.proc
	; source: library:/prog8lib/conv.p8:159   %asm {{
	    jsr  conv.uword2decimal
	    ldx  #0
_output_digits
	    ldy  #0
-           lda  conv.uword2decimal.decTenThousands,y
            beq  _allzero
            cmp  #'0'
            bne  _gotdigit
            iny
            bne  -
_gotdigit   sta  string_out,x
            inx
            iny
            lda  conv.uword2decimal.decTenThousands,y
            bne  _gotdigit
_end        lda  #0
            sta  string_out,x
            rts

_allzero    lda  #'0'
            sta  string_out,x
            inx
            bne  _end
	.pend
	; source: library:/prog8lib/conv.p8:186   asmsub  str_w  (word value @ AY) clobbers(A,X,Y)  {

str_w	.proc
	; source: library:/prog8lib/conv.p8:188   %asm {{
	    cpy  #0
	    bpl  str_uw
	    pha
	    lda  #'-'
	    sta  string_out
            tya
            eor  #255
            tay
            pla
            eor  #255
            clc
            adc  #1
            bcc  +
            iny
+	    jsr  conv.uword2decimal
	    ldx  #1
	    bne  str_uw._output_digits
  rts
	.pend
	; source: library:/prog8lib/conv.p8:212   asmsub  any2uword(str string @AY) clobbers(Y) -> ubyte @A {

any2uword	.proc
	; source: library:/prog8lib/conv.p8:218   %asm {{
	pha
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	ldy  P8ZP_SCRATCH_W1+1
	cmp  #'$'
	beq  _hex
	cmp  #'%'
	beq  _bin
	pla
	jsr  str2uword
	jmp  _result
_hex	pla
	jsr  hex2uword
	jmp  _result
_bin	pla
	jsr  bin2uword
_result
        pha
        lda  cx16.r15
        sta  P8ZP_SCRATCH_B1        ; result value
        pla
        sta  cx16.r15
        sty  cx16.r15+1
        lda  P8ZP_SCRATCH_B1
        rts
	.pend
	; source: library:/prog8lib/conv.p8:249   inline asmsub  str2ubyte(str string @AY) clobbers(Y) -> ubyte @A {
	; source: library:/prog8lib/conv.p8:259   inline asmsub  str2byte(str string @AY) clobbers(Y) -> byte @A {
	; source: library:/prog8lib/conv.p8:269   asmsub  str2uword(str string @AY) -> uword @AY {

str2uword	.proc
	; source: library:/prog8lib/conv.p8:274   %asm {{
_result = P8ZP_SCRATCH_W1
        	sta  P8ZP_SCRATCH_W2
        	sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sty  _result
		sty  _result+1
		sty  cx16.r15+1
_loop
		lda  (P8ZP_SCRATCH_W2),y
		sec
		sbc  #48
		bpl  _digit
_done
		sty  cx16.r15
		lda  _result
		ldy  _result+1
		rts
_digit
		cmp  #10
		bcs  _done
		; add digit to result
		pha
		jsr  _result_times_10
		pla
		clc
		adc  _result
		sta  _result
		bcc  +
		inc  _result+1
+		iny
		bne  _loop
		; never reached

_result_times_10     ; (W*4 + W)*2
		lda  _result+1
		sta  P8ZP_SCRATCH_REG
		lda  _result
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  _result
		sta  _result
		lda  P8ZP_SCRATCH_REG
		adc  _result+1
		asl  _result
		rol  a
		sta  _result+1
		rts
	.pend
	; source: library:/prog8lib/conv.p8:328   asmsub  str2word(str string @AY) -> word @AY {

str2word	.proc
	; source: library:/prog8lib/conv.p8:333   %asm {{
_result = P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sty  _result
		sty  _result+1
		sty  _negative
		sty  cx16.r15+1
		lda  (P8ZP_SCRATCH_W2),y
		cmp  #'+'
		bne  +
		iny
+		cmp  #'-'
		bne  _parse
		inc  _negative
		iny
_parse		lda  (P8ZP_SCRATCH_W2),y
		sec
		sbc  #48
		bpl  _digit
_done
		sty  cx16.r15
		lda  _negative
		beq  +
		sec
		lda  #0
		sbc  _result
		sta  _result
		lda  #0
		sbc  _result+1
		sta  _result+1
+		lda  _result
		ldy  _result+1
		rts
_digit
		cmp  #10
		bcs  _done
		; add digit to result
		pha
		jsr  str2uword._result_times_10
		pla
		clc
		adc  _result
		sta  _result
		bcc  +
		inc  _result+1
+		iny
		bne  _parse
		; never reached
_negative	.byte  0
	.pend
	; source: library:/prog8lib/conv.p8:387   asmsub  hex2uword(str string @AY) -> uword @AY {

hex2uword	.proc
	; source: library:/prog8lib/conv.p8:392   %asm {{
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	sty  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	sty  cx16.r15+1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #'$'
	bne  _loop
	iny
_loop
	lda  #0
	sta  P8ZP_SCRATCH_B1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #7                 ; screencode letters A-F are 1-6
	bcc  _add_letter
	and  #127
	cmp  #97
	bcs  _try_iso            ; maybe letter is iso:'a'-iso:'f' (97-102)
	cmp  #'g'
	bcs  _stop
	cmp  #'a'
	bcs  _add_letter
	cmp  #'0'
	bcc  _stop
	cmp  #'9'+1
	bcs  _stop
_calc
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	and  #$0f
	clc
	adc  P8ZP_SCRATCH_B1
	ora  P8ZP_SCRATCH_W1
	sta  P8ZP_SCRATCH_W1
	iny
	bne  _loop
_stop
	sty  cx16.r15
	lda  P8ZP_SCRATCH_W1
	ldy  P8ZP_SCRATCH_W1+1
	rts
_add_letter
	pha
	lda  #9
	sta  P8ZP_SCRATCH_B1
	pla
	jmp  _calc
_try_iso
        cmp  #103
        bcs  _stop
        and  #63
        bne  _add_letter
	.pend
	; source: library:/prog8lib/conv.p8:457   asmsub  bin2uword(str string @AY) -> uword @AY {

bin2uword	.proc
	; source: library:/prog8lib/conv.p8:461   %asm {{
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	sty  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	sty  cx16.r15+1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #'%'
	bne  _loop
	iny
_loop
	lda  (P8ZP_SCRATCH_W2),y
	cmp  #'0'
	bcc  _stop
	cmp  #'2'
	bcs  _stop
_first  asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	and  #1
	ora  P8ZP_SCRATCH_W1
	sta  P8ZP_SCRATCH_W1
	iny
	bne  _loop
_stop
	sty  cx16.r15
	lda  P8ZP_SCRATCH_W1
	ldy  P8ZP_SCRATCH_W1+1
	rts
	.pend
	; source: library:/prog8lib/conv.p8:497   asmsub  ubyte2decimal  (ubyte value @A) -> ubyte @Y, ubyte @A, ubyte @X  {

ubyte2decimal	.proc
	; source: library:/prog8lib/conv.p8:499   %asm {{
		ldy  #uword2decimal.ASCII_0_OFFSET
		jmp  uword2decimal.hex_try200
	.pend
	; source: library:/prog8lib/conv.p8:505   asmsub  uword2decimal  (uword value @AY) -> ubyte @Y, ubyte @A, ubyte @X  {

uword2decimal	.proc
	; source: library:/prog8lib/conv.p8:511   %asm {{
;Convert 16 bit Hex to Decimal (0-65535) Rev 2
;By Omegamatrix    Further optimizations by tepples
; routine from https://forums.nesdev.org/viewtopic.php?p=130363&sid=1944ba8bac4d6afa9c02e3cc42304e6b#p130363

;HexToDec99
; start in A
; end with A = 10's, decOnes (also in X)

;HexToDec255
; start in A
; end with Y = 100's, A = 10's, decOnes (also in X)

;HexToDec999
; start with A = high byte, Y = low byte
; end with Y = 100's, A = 10's, decOnes (also in X)
; requires 1 extra temp register on top of decOnes, could combine
; these two if HexToDec65535 was eliminated...

;HexToDec65535
; start with A/Y (low/high) as 16 bit value
; end with decTenThousand, decThousand, Y = 100's, A = 10's, decOnes (also in X)
; (irmen: I store Y and A in decHundreds and decTens too, so all of it can be easily printed)


ASCII_0_OFFSET 	= $30
temp       	    = P8ZP_SCRATCH_B1	; byte in zeropage
hexHigh      	= P8ZP_SCRATCH_W1	; byte in zeropage
hexLow       	= P8ZP_SCRATCH_W1+1	; byte in zeropage


HexToDec65535; SUBROUTINE
    sty    hexHigh               ;3  @9
    sta    hexLow                ;3  @12
    tya
    tax                          ;2  @14
    lsr    a                     ;2  @16
    lsr    a                     ;2  @18   integer divide 1024 (result 0-63)

    cpx    #$A7                  ;2  @20   account for overflow of multiplying 24 from 43,000 ($A7F8) onward,
    adc    #1                    ;2  @22   we can just round it to $A700, and the divide by 1024 is fine...

    ;at this point we have a number 1-65 that we have to times by 24,
    ;add to original sum, and Mod 1024 to get a remainder 0-999


    sta    temp                  ;3  @25
    asl    a                     ;2  @27
    adc    temp                  ;3  @30  x3
    tay                          ;2  @32
    lsr    a                     ;2  @34
    lsr    a                     ;2  @36
    lsr    a                     ;2  @38
    lsr    a                     ;2  @40
    lsr    a                     ;2  @42
    tax                          ;2  @44
    tya                          ;2  @46
    asl    a                     ;2  @48
    asl    a                     ;2  @50
    asl    a                     ;2  @52
    clc                          ;2  @54
    adc    hexLow                ;3  @57
    sta    hexLow                ;3  @60
    txa                          ;2  @62
    adc    hexHigh               ;3  @65
    sta    hexHigh               ;3  @68
    ror    a                     ;2  @70
    lsr    a                     ;2  @72
    tay                          ;2  @74    integer divide 1,000 (result 0-65)

    lsr    a                     ;2  @76    split the 1,000 and 10,000 digit
    tax                          ;2  @78
    lda    ShiftedBcdTab,x       ;4  @82
    tax                          ;2  @84
    rol    a                     ;2  @86
    and    #$0F                  ;2  @88
    ora    #ASCII_0_OFFSET
    sta    decThousands          ;3  @91
    txa                          ;2  @93
    lsr    a                     ;2  @95
    lsr    a                     ;2  @97
    lsr    a                     ;2  @99
    ora    #ASCII_0_OFFSET
    sta    decTenThousands       ;3  @102

    lda    hexLow                ;3  @105
    cpy    temp                  ;3  @108
    bmi    _doSubtract           ;2 @110/111
    beq    _useZero               ;2 @112/113
    adc    #23 + 24              ;2  @114
_doSubtract
    sbc    #23                   ;2  @116
    sta    hexLow                ;3  @119
_useZero
    lda    hexHigh               ;3  @122
    sbc    #0                    ;2  @124

Start100s
    and    #$03                  ;2  @126
    tax                          ;2  @128   0,1,2,3
    cmp    #2                    ;2  @130
    rol    a                     ;2  @132   0,2,5,7
    ora    #ASCII_0_OFFSET
    tay                          ;2  @134   Y = Hundreds digit

    lda    hexLow                ;3  @137
    adc    Mod100Tab,x           ;4  @141    adding remainder of 256, 512, and 256+512 (all mod 100)
    bcs    hex_doSub200             ;2 @143/144

hex_try200
    cmp    #200                  ;2  @145
    bcc    hex_try100               ;2 @147/148
hex_doSub200
    iny                          ;2  @149
    iny                          ;2  @151
    sbc    #200                  ;2  @153
hex_try100
    cmp    #100                  ;2  @155
    bcc    HexToDec99            ;2 @157/158
    iny                          ;2  @159
    sbc    #100                  ;2  @161

HexToDec99; SUBROUTINE
    lsr    a                     ;2  @163
    tax                          ;2  @165
    lda    ShiftedBcdTab,x       ;4  @169
    tax                          ;2  @171
    rol    a                     ;2  @173
    and    #$0F                  ;2  @175
    ora    #ASCII_0_OFFSET
    sta    decOnes               ;3  @178
    txa                          ;2  @180
    lsr    a                     ;2  @182
    lsr    a                     ;2  @184
    lsr    a                     ;2  @186
    ora    #ASCII_0_OFFSET

    ; irmen: load X with ones, and store Y and A too, for easy printing afterwards
    sty  decHundreds
    sta  decTens
    ldx  decOnes
    rts                          ;6  @192   Y=hundreds, A = tens digit, X=ones digit


HexToDec999; SUBROUTINE
    sty    hexLow                ;3  @9
    jmp    Start100s             ;3  @12

Mod100Tab
    .byte 0,56,12,56+12

ShiftedBcdTab
    .byte $00,$01,$02,$03,$04,$08,$09,$0A,$0B,$0C
    .byte $10,$11,$12,$13,$14,$18,$19,$1A,$1B,$1C
    .byte $20,$21,$22,$23,$24,$28,$29,$2A,$2B,$2C
    .byte $30,$31,$32,$33,$34,$38,$39,$3A,$3B,$3C
    .byte $40,$41,$42,$43,$44,$48,$49,$4A,$4B,$4C

decTenThousands   	.byte  0
decThousands    	.byte  0
decHundreds		.byte  0
decTens			.byte  0
decOnes   		.byte  0
			.byte  0		; zero-terminate the decimal output string
	.pend
	; source: library:/prog8lib/conv.p8:680   asmsub  byte2decimal  (byte value @A) -> ubyte @Y, ubyte @A, ubyte @X  {

byte2decimal	.proc
	; source: library:/prog8lib/conv.p8:683   %asm {{
		cmp  #0
		bpl  +
		eor  #255
		clc
		adc  #1
+		jmp  ubyte2decimal
	.pend
	; source: library:/prog8lib/conv.p8:693   asmsub  ubyte2hex  (ubyte value @A) clobbers(X) -> ubyte @A, ubyte @Y  {

ubyte2hex	.proc
	; source: library:/prog8lib/conv.p8:695   %asm {{
		pha
		and  #$0f
		tax
		ldy  _hex_digits,x
		pla
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		tax
		lda  _hex_digits,x
		rts

_hex_digits	.text "0123456789abcdef"	; can probably be reused for other stuff as well
	.pend
	; source: library:/prog8lib/conv.p8:713   asmsub  uword2hex  (uword value @AY) clobbers(A,Y)  {

uword2hex	.proc
	; source: library:/prog8lib/conv.p8:715   %asm {{
		sta  P8ZP_SCRATCH_REG
		tya
		jsr  ubyte2hex
		sta  output
		sty  output+1
		lda  P8ZP_SCRATCH_REG
		jsr  ubyte2hex
		sta  output+2
		sty  output+3
		rts
output		.text  "0000", $00      ; 0-terminated output buffer (to make printing easier)
	.pend
	.pend

; ---- block: 'string' ----
string	.proc
	; source: library:/prog8lib/string.p8:3   string {


	; source: library:/prog8lib/string.p8:4   %option no_symbol_prefixing
	; source: library:/prog8lib/string.p8:6   asmsub length(uword string @AY) clobbers(A) -> ubyte @Y {

length	.proc
	; source: library:/prog8lib/string.p8:11   %asm {{
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  +
		iny
		bne  -
+		rts
	.pend
	; source: library:/prog8lib/string.p8:23   asmsub left(uword source @R0, ubyte length @A, uword target @R1) clobbers(A, Y) {

left	.proc
	; source: library:/prog8lib/string.p8:28   %asm {{
                ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		ldy  cx16.r0
		sty  P8ZP_SCRATCH_W1
		ldy  cx16.r0+1
		sty  P8ZP_SCRATCH_W1+1
		ldy  cx16.r1
		sty  P8ZP_SCRATCH_W2
		ldy  cx16.r1+1
		sty  P8ZP_SCRATCH_W2+1
		tay
		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
		rts
_loop		dey
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
+		rts
	.pend
	; source: library:/prog8lib/string.p8:54   asmsub right(uword source @R0, ubyte length @A, uword target @R1) clobbers(A,Y) {

right	.proc
	; source: library:/prog8lib/string.p8:59   %asm {{
                ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
                sta  P8ZP_SCRATCH_B1
                lda  cx16.r0
                ldy  cx16.r0+1
                jsr  string.length
                tya
                sec
                sbc  P8ZP_SCRATCH_B1
                clc
                adc  cx16.r0
		sta  P8ZP_SCRATCH_W1
		lda  cx16.r0+1
		adc  #0
		sta  P8ZP_SCRATCH_W1+1
		ldy  cx16.r1
		sty  P8ZP_SCRATCH_W2
		ldy  cx16.r1+1
		sty  P8ZP_SCRATCH_W2+1
		ldy  P8ZP_SCRATCH_B1
		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
		rts
_loop		dey
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
+		rts
	.pend
	; source: library:/prog8lib/string.p8:93   asmsub slice(uword source @R0, ubyte start @A, ubyte length @Y, uword target @R1) clobbers(A, Y) {

slice	.proc
	; source: library:/prog8lib/string.p8:99   %asm {{
                ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		; substr(source, target, start, length)
		sta  P8ZP_SCRATCH_B1
		lda  cx16.r0
		sta  P8ZP_SCRATCH_W1
		lda  cx16.r0+1
		sta  P8ZP_SCRATCH_W1+1
		lda  cx16.r1
		sta  P8ZP_SCRATCH_W2
		lda  cx16.r1+1
		sta  P8ZP_SCRATCH_W2+1

		; adjust src location
		clc
		lda  P8ZP_SCRATCH_W1
		adc  P8ZP_SCRATCH_B1
		sta  P8ZP_SCRATCH_W1
		bcc  +
		inc  P8ZP_SCRATCH_W1+1
+		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		beq  _startloop
-		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
_startloop	dey
		cpy  #$ff
		bne  -
		rts
	.pend
	; source: library:/prog8lib/string.p8:131   asmsub find(uword string @R0, ubyte character @A) -> ubyte @A, bool @Pc {

find	.proc
	; source: library:/prog8lib/string.p8:134   %asm {{
                ; need to copy the the cx16 virtual registers to zeropage to make this run on C64...
                sta  P8ZP_SCRATCH_B1
		lda  cx16.r0
		ldy  cx16.r0+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  _notfound
		cmp  P8ZP_SCRATCH_B1
		beq  _found
		iny
		bne  -
_notfound	lda  #0
                clc
		rts
_found		tya
                sec
                rts
	.pend
	; source: library:/prog8lib/string.p8:157   asmsub copy(uword source @R0, uword target @AY) clobbers(A) -> ubyte @Y {

copy	.proc
	; source: library:/prog8lib/string.p8:162   %asm {{
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend
	; source: library:/prog8lib/string.p8:171   asmsub compare(uword string1 @R0, uword string2 @AY) clobbers(Y) -> byte @A {

compare	.proc
	; source: library:/prog8lib/string.p8:176   %asm {{
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcmp_mem
	.pend
	; source: library:/prog8lib/string.p8:185   asmsub lower(uword st @AY) -> ubyte @Y {

lower	.proc
	; source: library:/prog8lib/string.p8:189   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  _done
            and  #$7f
            cmp  #97
            bcc  +
            cmp  #123
            bcs  +
            and  #%11011111
+           sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
_done       rts
	.pend
	; source: library:/prog8lib/string.p8:208   asmsub upper(uword st @AY) -> ubyte @Y {

upper	.proc
	; source: library:/prog8lib/string.p8:210   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  _done
            cmp  #65
            bcc  +
            cmp  #91
            bcs  +
            ora  #%00100000
+           sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
_done       rts
	.pend
	; source: library:/prog8lib/string.p8:228   asmsub lowerchar(ubyte character @A) -> ubyte @A {

lowerchar	.proc
	; source: library:/prog8lib/string.p8:229   %asm {{
            and  #$7f
            cmp  #97
            bcc  +
            cmp  #123
            bcs  +
            and  #%11011111
+           rts
	.pend
	; source: library:/prog8lib/string.p8:240   asmsub upperchar(ubyte character @A) -> ubyte @A {

upperchar	.proc
	; source: library:/prog8lib/string.p8:241   %asm {{
            cmp  #65
            bcc  +
            cmp  #91
            bcs  +
            ora  #%00100000
+           rts
	.pend
	; source: library:/prog8lib/string.p8:271   asmsub pattern_match(str string @AY, str pattern @R0) clobbers(Y) -> ubyte @A {

pattern_match	.proc
	; source: library:/prog8lib/string.p8:272   %asm {{
; pattern matching of a string.
; Input:  cx16.r0:  A NUL-terminated, <255-length pattern
;              AY:  A NUL-terminated, <255-length string
;
; Output: A = 1 if the string matches the pattern, A = 0 if not.
;
; Notes:  Clobbers A, X, Y. Each * in the pattern uses 4 bytes of stack.
;
; see http://6502.org/source/strings/patmatch.htm

strptr = P8ZP_SCRATCH_W1

	sta  strptr
	sty  strptr+1
	lda  cx16.r0
	sta  modify_pattern1+1
	sta  modify_pattern2+1
	lda  cx16.r0+1
	sta  modify_pattern1+2
	sta  modify_pattern2+2
	jsr  _match
	lda  #0
	rol  a
	rts


_match
	ldx #$00        ; x is an index in the pattern
	ldy #$ff        ; y is an index in the string
modify_pattern1
next    lda $ffff,x   ; look at next pattern character    MODIFIED
	cmp #'*'     ; is it a star?
	beq star        ; yes, do the complicated stuff
	iny             ; no, let's look at the string
	cmp #'?'     ; is the pattern caracter a ques?
	bne reg         ; no, it's a regular character
	lda (strptr),y     ; yes, so it will match anything
	beq fail        ;  except the end of string
reg     cmp (strptr),y     ; are both characters the same?
	bne fail        ; no, so no match
	inx             ; yes, keep checking
	cmp #0          ; are we at end of string?
	bne next        ; not yet, loop
found   rts             ; success, return with c=1

star    inx             ; skip star in pattern
modify_pattern2
	cmp $ffff,x   	; string of stars equals one star	MODIFIED
	beq star        ;  so skip them also
stloop  txa             ; we first try to match with * = ""
	pha             ;  and grow it by 1 character every
	tya             ;  time we loop
	pha             ; save x and y on stack
	jsr next        ; recursive call
	pla             ; restore x and y
	tay
	pla
	tax
	bcs found       ; we found a match, return with c=1
	iny             ; no match yet, try to grow * string
	lda (strptr),y     ; are we at the end of string?
	bne stloop      ; not yet, add a character
fail    clc             ; yes, no match found, return with c=0
	rts
	.pend
	.pend

; ---- block: 'p8_fmalloc_root' ----
p8_fmalloc_root	.proc
	; source: src\fmalloc.p8:6   
	p8_FMALLOC_assigned = 3
	p8_FMALLOC_available = 0
	p8_FMALLOC_freemem = 6
	p8_FMALLOC_totalmem = 8
	p8_FMALLOC_totalnodes = 10
	p8_SIZEOF_FMALLOC = 12


	; source: src\fmalloc.p8:8   
	; source: src\fmalloc.p8:9   
	; source: src\fmalloc.p8:10   
	; source: src\fmalloc.p8:11   fmalloc_root {
	; source: src\fmalloc.p8:12   
	; source: src\fmalloc.p8:13   
	; source: src\fmalloc.p8:15   const ubyte SIZEOF_FMALLOC      = $0c;

p8_available_get	.proc
; statements
	; source: src\fmalloc.p8:16   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  p8_result
	sta  cx16.r1
	lda  p8_result+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_struct.p8_get
	; source: src\fmalloc.p8:15   const ubyte SIZEOF_FMALLOC      = $0c;
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_result	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:19   const ubyte FMALLOC_assigned    = $03; ubyte[3]

p8_available_set	.proc
; statements
	; source: src\fmalloc.p8:20   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_struct.p8_set
	; source: src\fmalloc.p8:19   const ubyte FMALLOC_assigned    = $03; ubyte[3]
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_value	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:27   

p8_assigned_set	.proc
; statements
	; source: src\fmalloc.p8:28   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  #3
	sta  cx16.r2
	stz  cx16.r2+1
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_struct.p8_set
	; source: src\fmalloc.p8:27   
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_value	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:31   struct.get(ptr, FMALLOC_available, fptr.SIZEOF_FPTR, result);

p8_freemem_get	.proc
; statements
	; source: src\fmalloc.p8:32   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  p8_result
	sta  cx16.r1
	lda  p8_result+1
	sta  cx16.r1+1
	
	ldy  #6
	jmp  p8_struct.p8_get_w
	; source: src\fmalloc.p8:31   struct.get(ptr, FMALLOC_available, fptr.SIZEOF_FPTR, result);
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_result	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:35   

p8_freemem_set	.proc
; statements
	; source: src\fmalloc.p8:36   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldy  #6
	jmp  p8_struct.p8_set_w
	; source: src\fmalloc.p8:35   
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_value	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:39   struct.set(ptr, FMALLOC_available, fptr.SIZEOF_FPTR, value);

p8_freemem_set_wi	.proc
; statements
	; source: src\fmalloc.p8:40   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldy  #6
	jmp  p8_struct.p8_set_wi
	; source: src\fmalloc.p8:39   struct.set(ptr, FMALLOC_available, fptr.SIZEOF_FPTR, value);
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_value	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:43   

p8_totalmem_get	.proc
; statements
	; source: src\fmalloc.p8:44   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  p8_result
	sta  cx16.r1
	lda  p8_result+1
	sta  cx16.r1+1
	
	ldy  #8
	jmp  p8_struct.p8_get_w
	; source: src\fmalloc.p8:43   
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_result	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:47   struct.get(ptr, FMALLOC_assigned, fptr.SIZEOF_FPTR, result);

p8_totalmem_set	.proc
; statements
	; source: src\fmalloc.p8:48   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldy  #8
	jmp  p8_struct.p8_set_w
	; source: src\fmalloc.p8:47   struct.get(ptr, FMALLOC_assigned, fptr.SIZEOF_FPTR, result);
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_value	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:51   

p8_totalmem_set_wi	.proc
; statements
	; source: src\fmalloc.p8:52   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldy  #8
	jmp  p8_struct.p8_set_wi
	; source: src\fmalloc.p8:51   
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_value	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:55   struct.set(ptr, FMALLOC_assigned, fptr.SIZEOF_FPTR, value);

p8_totalnodes_get	.proc
; statements
	; source: src\fmalloc.p8:56   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  p8_result
	sta  cx16.r1
	lda  p8_result+1
	sta  cx16.r1+1
	
	ldy  #10
	jmp  p8_struct.p8_get_w
	; source: src\fmalloc.p8:55   struct.set(ptr, FMALLOC_assigned, fptr.SIZEOF_FPTR, value);
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_result	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:59   

p8_totalnodes_set	.proc
; statements
	; source: src\fmalloc.p8:60   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldy  #10
	jmp  p8_struct.p8_set_w
	; source: src\fmalloc.p8:59   
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_value	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:63   struct.get_w(ptr, FMALLOC_freemem, result);

p8_totalnodes_set_wi	.proc
; statements
	; source: src\fmalloc.p8:64   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldy  #10
	jmp  p8_struct.p8_set_wi
	; source: src\fmalloc.p8:63   struct.get_w(ptr, FMALLOC_freemem, result);
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_value	.word  ?
	.send BSS
	.pend
	.pend

; ---- block: 'p8_fmalloc_item' ----
p8_fmalloc_item	.proc
	; source: src\fmalloc.p8:69   sub freemem_set(uword ptr, uword value) {
	p8_FMALLOC_ITEM_next = 3
	p8_FMALLOC_ITEM_prev = 0
	p8_FMALLOC_ITEM_size = 6
	p8_SIZEOF_FMALLOC_ITEM = 8


	; source: src\fmalloc.p8:70   
	; source: src\fmalloc.p8:71   struct.set_w(ptr, FMALLOC_freemem, value);
	; source: src\fmalloc.p8:72   
	; source: src\fmalloc.p8:73   }
	; source: src\fmalloc.p8:75   

p8_next_get	.proc
; statements
	; source: src\fmalloc.p8:76   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  #3
	sta  cx16.r2
	stz  cx16.r2+1
	lda  p8_result
	sta  cx16.r1
	lda  p8_result+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_get
	; source: src\fmalloc.p8:75   
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_result	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:79   struct.set_wi(ptr, FMALLOC_freemem, value);

p8_next_set	.proc
; statements
	; source: src\fmalloc.p8:80   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  #3
	sta  cx16.r2
	stz  cx16.r2+1
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_set
	; source: src\fmalloc.p8:79   struct.set_wi(ptr, FMALLOC_freemem, value);
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_value	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:83   

p8_prev_get	.proc
; statements
	; source: src\fmalloc.p8:84   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  p8_result
	sta  cx16.r1
	lda  p8_result+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_get
	; source: src\fmalloc.p8:83   
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_result	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:87   struct.get_w(ptr, FMALLOC_totalmem, result);

p8_prev_set	.proc
; statements
	; source: src\fmalloc.p8:88   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_set
	; source: src\fmalloc.p8:87   struct.get_w(ptr, FMALLOC_totalmem, result);
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_value	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:91   

p8_size_get	.proc
; statements
	; source: src\fmalloc.p8:92   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  p8_result
	sta  cx16.r1
	lda  p8_result+1
	sta  cx16.r1+1
	
	ldy  #6
	jmp  p8_fstruct.p8_get_w
	; source: src\fmalloc.p8:91   
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_result	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:95   struct.set_w(ptr, FMALLOC_totalmem, value);

p8_size_set	.proc
; statements
	; source: src\fmalloc.p8:96   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldy  #6
	jmp  p8_fstruct.p8_set_w
	; source: src\fmalloc.p8:95   struct.set_w(ptr, FMALLOC_totalmem, value);
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_ptr	.word  ?
p8_value	.word  ?
	.send BSS
	.pend
	.pend

; ---- block: 'p8_fmalloc' ----
p8_fmalloc	.proc
	; source: src\fmalloc.p8:104   


	; source: src\fmalloc.p8:107   

p8_init	.proc
; simple int arg(s) passed via register(s)
	sta  p8_pm
	sty  p8_pm+1
; statements
	; source: src\fmalloc.p8:108   
	sta  p8_fmalloc_root.p8_available_set.p8_ptr
	sty  p8_fmalloc_root.p8_available_set.p8_ptr+1
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fmalloc_root.p8_available_set.p8_value
	sty  p8_fmalloc_root.p8_available_set.p8_value+1
	
	jsr  p8_fmalloc_root.p8_available_set
	; source: src\fmalloc.p8:109   sub totalnodes_get(uword ptr, uword result) {
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_assigned_set.p8_ptr
	sty  p8_fmalloc_root.p8_assigned_set.p8_ptr+1
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fmalloc_root.p8_assigned_set.p8_value
	sty  p8_fmalloc_root.p8_assigned_set.p8_value+1
	
	jsr  p8_fmalloc_root.p8_assigned_set
	; source: src\fmalloc.p8:110   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_freemem_set_wi.p8_ptr
	sty  p8_fmalloc_root.p8_freemem_set_wi.p8_ptr+1
	stz  p8_fmalloc_root.p8_freemem_set_wi.p8_value
	stz  p8_fmalloc_root.p8_freemem_set_wi.p8_value+1
	jsr  p8_fmalloc_root.p8_freemem_set_wi
	; source: src\fmalloc.p8:111   struct.get_w(ptr, FMALLOC_totalnodes, result);
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_totalmem_set_wi.p8_ptr
	sty  p8_fmalloc_root.p8_totalmem_set_wi.p8_ptr+1
	stz  p8_fmalloc_root.p8_totalmem_set_wi.p8_value
	stz  p8_fmalloc_root.p8_totalmem_set_wi.p8_value+1
	jsr  p8_fmalloc_root.p8_totalmem_set_wi
	; source: src\fmalloc.p8:112   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_totalnodes_set_wi.p8_ptr
	sty  p8_fmalloc_root.p8_totalnodes_set_wi.p8_ptr+1
	stz  p8_fmalloc_root.p8_totalnodes_set_wi.p8_value
	stz  p8_fmalloc_root.p8_totalnodes_set_wi.p8_value+1
	jmp  p8_fmalloc_root.p8_totalnodes_set_wi
	; source: src\fmalloc.p8:107   
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_pm	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:116   

p8_addblock	.proc
; statements
	; source: src\fmalloc.p8:119   struct.set_w(ptr, FMALLOC_totalnodes, value);
	; source: src\fmalloc.p8:123   
	; source: src\fmalloc.p8:128   
	; source: src\fmalloc.p8:137   fmalloc_item {
	; source: src\fmalloc.p8:119   struct.set_w(ptr, FMALLOC_totalnodes, value);
	lda  p8_size
	ldy  p8_size+1
	sta  p8_usableSize
	sty  p8_usableSize+1
	sec
	sbc  #8
	sta  p8_usableSize
	bcs  +
	dec  p8_usableSize+1
+
	; source: src\fmalloc.p8:120   
	lda  p8_ptr
	ldy  p8_ptr+1
	sta  p8_fmalloc_item.p8_size_set.p8_ptr
	sty  p8_fmalloc_item.p8_size_set.p8_ptr+1
	lda  #<p8_usableSize+0
	ldy  #>p8_usableSize+0
	sta  p8_fmalloc_item.p8_size_set.p8_value
	sty  p8_fmalloc_item.p8_size_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_size_set
	; source: src\fmalloc.p8:123   
	stz  p8_freemem
	stz  p8_freemem+1
	; source: src\fmalloc.p8:124   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_freemem_get.p8_ptr
	sty  p8_fmalloc_root.p8_freemem_get.p8_ptr+1
	lda  #<p8_freemem+0
	ldy  #>p8_freemem+0
	sta  p8_fmalloc_root.p8_freemem_get.p8_result
	sty  p8_fmalloc_root.p8_freemem_get.p8_result+1
	
	jsr  p8_fmalloc_root.p8_freemem_get
	; source: src\fmalloc.p8:125   sub totalnodes_set_wi(uword ptr, uword value) {
	lda  p8_freemem
	clc
	adc  p8_usableSize
	sta  p8_freemem
	lda  p8_freemem+1
	adc  p8_usableSize+1
	sta  p8_freemem+1
	; source: src\fmalloc.p8:126   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_freemem_set.p8_ptr
	sty  p8_fmalloc_root.p8_freemem_set.p8_ptr+1
	lda  #<p8_freemem+0
	ldy  #>p8_freemem+0
	sta  p8_fmalloc_root.p8_freemem_set.p8_value
	sty  p8_fmalloc_root.p8_freemem_set.p8_value+1
	
	jsr  p8_fmalloc_root.p8_freemem_set
	; source: src\fmalloc.p8:128   
	stz  p8_totalmem
	stz  p8_totalmem+1
	; source: src\fmalloc.p8:129   }
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_totalmem_get.p8_ptr
	sty  p8_fmalloc_root.p8_totalmem_get.p8_ptr+1
	lda  #<p8_totalmem+0
	ldy  #>p8_totalmem+0
	sta  p8_fmalloc_root.p8_totalmem_get.p8_result
	sty  p8_fmalloc_root.p8_totalmem_get.p8_result+1
	
	jsr  p8_fmalloc_root.p8_totalmem_get
	; source: src\fmalloc.p8:130   
	lda  p8_totalmem
	clc
	adc  p8_usableSize
	sta  p8_totalmem
	lda  p8_totalmem+1
	adc  p8_usableSize+1
	sta  p8_totalmem+1
	; source: src\fmalloc.p8:131   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_totalmem_set.p8_ptr
	sty  p8_fmalloc_root.p8_totalmem_set.p8_ptr+1
	lda  #<p8_totalmem+0
	ldy  #>p8_totalmem+0
	sta  p8_fmalloc_root.p8_totalmem_set.p8_value
	sty  p8_fmalloc_root.p8_totalmem_set.p8_value+1
	
	jsr  p8_fmalloc_root.p8_totalmem_set
	; source: src\fmalloc.p8:134   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc.p8_insert_item.p8_root
	sty  p8_fmalloc.p8_insert_item.p8_root+1
	lda  p8_ptr
	ldy  p8_ptr+1
	sta  p8_fmalloc.p8_insert_item.p8_node
	sty  p8_fmalloc.p8_insert_item.p8_node+1
	jsr  p8_fmalloc.p8_insert_item
	; source: src\fmalloc.p8:137   fmalloc_item {
	stz  p8_totalnodes
	stz  p8_totalnodes+1
	; source: src\fmalloc.p8:138   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_totalnodes_get.p8_ptr
	sty  p8_fmalloc_root.p8_totalnodes_get.p8_ptr+1
	lda  #<p8_totalnodes+0
	ldy  #>p8_totalnodes+0
	sta  p8_fmalloc_root.p8_totalnodes_get.p8_result
	sty  p8_fmalloc_root.p8_totalnodes_get.p8_result+1
	
	jsr  p8_fmalloc_root.p8_totalnodes_get
	; source: src\fmalloc.p8:139   const ubyte SIZEOF_FMALLOC_ITEM = $08;
	inc  p8_totalnodes
	bne  +
	inc  p8_totalnodes+1
+
	; source: src\fmalloc.p8:140   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_totalnodes_set.p8_ptr
	sty  p8_fmalloc_root.p8_totalnodes_set.p8_ptr+1
	lda  #<p8_totalnodes+0
	ldy  #>p8_totalnodes+0
	sta  p8_fmalloc_root.p8_totalnodes_set.p8_value
	sty  p8_fmalloc_root.p8_totalnodes_set.p8_value+1
	
	jmp  p8_fmalloc_root.p8_totalnodes_set
	; source: src\fmalloc.p8:116   
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_freemem	.word  ?
p8_pm	.word  ?
p8_ptr	.word  ?
p8_size	.word  ?
p8_totalmem	.word  ?
p8_totalnodes	.word  ?
p8_usableSize	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:146   

p8_malloc	.proc
; statements
	; source: src\fmalloc.p8:207   fmalloc {
	; source: src\fmalloc.p8:189   sub size_set(ubyte[3] ptr, uword value) {
	; source: src\fmalloc.p8:187   
	; source: src\fmalloc.p8:182   
	; source: src\fmalloc.p8:147   
	; source: src\fmalloc.p8:148   
	; source: src\fmalloc.p8:149   sub next_get(ubyte[3] ptr, uword result) {
	; source: src\fmalloc.p8:150   
	; source: src\fmalloc.p8:207   fmalloc {
	stz  p8_totalnodes
	stz  p8_totalnodes+1
	; source: src\fmalloc.p8:148   
	stz  p8_current_size
	stz  p8_current_size+1
	; source: src\fmalloc.p8:149   sub next_get(ubyte[3] ptr, uword result) {
	stz  p8_freemem
	stz  p8_freemem+1
	; source: src\fmalloc.p8:150   
	stz  p8_temp_result
	stz  p8_temp_result+1
	; source: src\fmalloc.p8:153   }
	lda  p8_size
	clc
	adc  #8
	sta  p8_size
	bcc  +
	inc  p8_size+1
+
	; source: src\fmalloc.p8:154   
	ldy  p8_size+1
	lda  p8_size
	clc
	adc  #<7
	tax
	tya
	adc  #>7
	tay
	txa
	and  #<$fff8
	tax
	tya
	and  #>$fff8
	tay
	txa
	sta  p8_size
	sty  p8_size+1
	; source: src\fmalloc.p8:155   
	sec
	sbc  #8
	sta  p8_size
	bcs  +
	dec  p8_size+1
+
	; source: src\fmalloc.p8:158   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_available_get.p8_ptr
	sty  p8_fmalloc_root.p8_available_get.p8_ptr+1
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_root.p8_available_get.p8_result
	sty  p8_fmalloc_root.p8_available_get.p8_result+1
	
	jsr  p8_fmalloc_root.p8_available_get
	; source: src\fmalloc.p8:159   fstruct.set(ptr, FMALLOC_ITEM_next, fptr.SIZEOF_FPTR, value);
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_size_get.p8_ptr
	sty  p8_fmalloc_item.p8_size_get.p8_ptr+1
	
	lda  #<p8_current_size+0
	ldy  #>p8_current_size+0
	sta  p8_fmalloc_item.p8_size_get.p8_result
	sty  p8_fmalloc_item.p8_size_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_size_get
	; source: src\fmalloc.p8:160   
p8_prog8_label_5_whileloop
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	beq  +
	lda  #1
+
	pha
	lda  p8_size
	ldy  p8_size+1
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldy  p8_current_size+1
	lda  p8_current_size
		cpy  P8ZP_SCRATCH_W1+1
		bcc  +
	bne  ++
		cmp  P8ZP_SCRATCH_W1
		bcs  ++
+       lda  #1
	bne  ++
+       lda  #0
+
	sta  P8ZP_SCRATCH_B1
	pla
	and  P8ZP_SCRATCH_B1
	beq  p8_prog8_label_6_afterwhile
	; source: src\fmalloc.p8:161   }
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_next_get.p8_ptr
	sty  p8_fmalloc_item.p8_next_get.p8_ptr+1
	
	sta  p8_fmalloc_item.p8_next_get.p8_result
	sty  p8_fmalloc_item.p8_next_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_next_get
	; source: src\fmalloc.p8:162   
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_size_get.p8_ptr
	sty  p8_fmalloc_item.p8_size_get.p8_ptr+1
	
	lda  #<p8_current_size+0
	ldy  #>p8_current_size+0
	sta  p8_fmalloc_item.p8_size_get.p8_result
	sty  p8_fmalloc_item.p8_size_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_size_get
	; source: src\fmalloc.p8:160   
	bra  p8_prog8_label_5_whileloop
p8_prog8_label_6_afterwhile
	; source: src\fmalloc.p8:166   
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #0
	bne  prog8_label_asm_5_if_end
	; source: src\fmalloc.p8:167   fstruct.get(ptr, FMALLOC_ITEM_prev, fptr.SIZEOF_FPTR, result);
	lda  #0
	ldy  p8_result
	sty  P8ZP_SCRATCH_W2
	ldy  p8_result+1
	sty  P8ZP_SCRATCH_W2+1
	sta  (P8ZP_SCRATCH_W2)
	; source: src\fmalloc.p8:168   
	ldy  #1
	lda  p8_result
	sta  P8ZP_SCRATCH_W2
	lda  p8_result+1
	sta  P8ZP_SCRATCH_W2+1
	lda  #0
	sta  (P8ZP_SCRATCH_W2),y
	; source: src\fmalloc.p8:169   }
	ldy  #2
	lda  p8_result
	sta  P8ZP_SCRATCH_W2
	lda  p8_result+1
	sta  P8ZP_SCRATCH_W2+1
	lda  #0
	sta  (P8ZP_SCRATCH_W2),y
prog8_label_asm_5_if_end
	; source: src\fmalloc.p8:173   sub prev_set(ubyte[3] ptr, uword value) {
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc.p8_remove_item.p8_root
	sty  p8_fmalloc.p8_remove_item.p8_root+1
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc.p8_remove_item.p8_node
	sty  p8_fmalloc.p8_remove_item.p8_node+1
	
	jsr  p8_fmalloc.p8_remove_item
	; source: src\fmalloc.p8:176   
	ldy  p8_pm+1
	lda  p8_pm
	clc
	adc  #<3
	tax
	tya
	adc  #>3
	tay
	txa
	sta  p8_fmalloc.p8_insert_item.p8_root
	sty  p8_fmalloc.p8_insert_item.p8_root+1
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc.p8_insert_item.p8_node
	sty  p8_fmalloc.p8_insert_item.p8_node+1
	
	jsr  p8_fmalloc.p8_insert_item
	; source: src\fmalloc.p8:179   
	ldy  p8_current_size+1
	lda  p8_current_size
	cmp  p8_size
	bne  +
	cpy  p8_size+1
	beq  prog8_label_asm_6_if_end
+
	; source: src\fmalloc.p8:183   fstruct.get_w(ptr, FMALLOC_ITEM_size, result);
	lda  p8_current+1
	pha
	lda  p8_current+2
	tay
	pla
	clc
	adc  #<8
	tax
	tya
	adc  #>8
	tay
	txa
	clc
	adc  p8_size
	tax
	tya
	adc  p8_size+1
	tay
	txa
	sta  p8_temp_result
	sty  p8_temp_result+1
	; source: src\fmalloc.p8:184   
	lda  p8_current+0
	sta  p8_newfree+0
	; source: src\fmalloc.p8:185   }
	lda  p8_temp_result
	sta  p8_newfree+1
	; source: src\fmalloc.p8:186   
	lda  p8_temp_result+1
	sta  p8_newfree+2
	; source: src\fmalloc.p8:187   
	ldy  p8_current_size+1
	lda  p8_current_size
	sec
	sbc  #<8
	tax
	tya
	sbc  #>8
	tay
	txa
	sec
	sbc  p8_size
	tax
	tya
	sbc  p8_size+1
	tay
	txa
	sta  p8_new_size
	sty  p8_new_size+1
	; source: src\fmalloc.p8:188   
	lda  #<p8_newfree+0
	ldy  #>p8_newfree+0
	sta  p8_fmalloc_item.p8_size_set.p8_ptr
	sty  p8_fmalloc_item.p8_size_set.p8_ptr+1
	
	lda  #<p8_new_size+0
	ldy  #>p8_new_size+0
	sta  p8_fmalloc_item.p8_size_set.p8_value
	sty  p8_fmalloc_item.p8_size_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_size_set
	; source: src\fmalloc.p8:190   
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_next_get.p8_ptr
	sty  p8_fmalloc_item.p8_next_get.p8_ptr+1
	
	lda  #<p8_current_next+0
	ldy  #>p8_current_next+0
	sta  p8_fmalloc_item.p8_next_get.p8_result
	sty  p8_fmalloc_item.p8_next_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_next_get
	; source: src\fmalloc.p8:191   fstruct.set_w(ptr, FMALLOC_ITEM_size, value);
	lda  #<p8_newfree+0
	ldy  #>p8_newfree+0
	sta  p8_fmalloc_item.p8_next_set.p8_ptr
	sty  p8_fmalloc_item.p8_next_set.p8_ptr+1
	
	lda  #<p8_current_next+0
	ldy  #>p8_current_next+0
	sta  p8_fmalloc_item.p8_next_set.p8_value
	sty  p8_fmalloc_item.p8_next_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_next_set
	; source: src\fmalloc.p8:192   
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_next_set.p8_ptr
	sty  p8_fmalloc_item.p8_next_set.p8_ptr+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fmalloc_item.p8_next_set.p8_value
	sty  p8_fmalloc_item.p8_next_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_next_set
	; source: src\fmalloc.p8:195   
	lda  p8_size
	ldy  p8_size+1
	sta  p8_current_size
	sty  p8_current_size+1
	; source: src\fmalloc.p8:196   
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_size_set.p8_ptr
	sty  p8_fmalloc_item.p8_size_set.p8_ptr+1
	
	lda  #<p8_current_size+0
	ldy  #>p8_current_size+0
	sta  p8_fmalloc_item.p8_size_set.p8_value
	sty  p8_fmalloc_item.p8_size_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_size_set
	; source: src\fmalloc.p8:199   fstruct.set_wi(ptr, FMALLOC_ITEM_size, value);
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc.p8_insert_item.p8_root
	sty  p8_fmalloc.p8_insert_item.p8_root+1
	lda  #<p8_newfree+0
	ldy  #>p8_newfree+0
	sta  p8_fmalloc.p8_insert_item.p8_node
	sty  p8_fmalloc.p8_insert_item.p8_node+1
	
	jsr  p8_fmalloc.p8_insert_item
	; source: src\fmalloc.p8:202   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_freemem_get.p8_ptr
	sty  p8_fmalloc_root.p8_freemem_get.p8_ptr+1
	lda  #<p8_freemem+0
	ldy  #>p8_freemem+0
	sta  p8_fmalloc_root.p8_freemem_get.p8_result
	sty  p8_fmalloc_root.p8_freemem_get.p8_result+1
	
	jsr  p8_fmalloc_root.p8_freemem_get
	; source: src\fmalloc.p8:203   }
	lda  p8_freemem
	sec
	sbc  #8
	sta  p8_freemem
	bcs  +
	dec  p8_freemem+1
+
	; source: src\fmalloc.p8:204   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_freemem_set.p8_ptr
	sty  p8_fmalloc_root.p8_freemem_set.p8_ptr+1
	lda  #<p8_freemem+0
	ldy  #>p8_freemem+0
	sta  p8_fmalloc_root.p8_freemem_set.p8_value
	sty  p8_fmalloc_root.p8_freemem_set.p8_value+1
	
	jsr  p8_fmalloc_root.p8_freemem_set
	; source: src\fmalloc.p8:208   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_totalnodes_get.p8_ptr
	sty  p8_fmalloc_root.p8_totalnodes_get.p8_ptr+1
	lda  #<p8_totalnodes+0
	ldy  #>p8_totalnodes+0
	sta  p8_fmalloc_root.p8_totalnodes_get.p8_result
	sty  p8_fmalloc_root.p8_totalnodes_get.p8_result+1
	
	jsr  p8_fmalloc_root.p8_totalnodes_get
	; source: src\fmalloc.p8:209   ;const ubyte FMALLOC_ITEM_next   = $03; ubyte[3]
	inc  p8_totalnodes
	bne  +
	inc  p8_totalnodes+1
+
	; source: src\fmalloc.p8:210   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_totalnodes_set.p8_ptr
	sty  p8_fmalloc_root.p8_totalnodes_set.p8_ptr+1
	lda  #<p8_totalnodes+0
	ldy  #>p8_totalnodes+0
	sta  p8_fmalloc_root.p8_totalnodes_set.p8_value
	sty  p8_fmalloc_root.p8_totalnodes_set.p8_value+1
	
	jsr  p8_fmalloc_root.p8_totalnodes_set
prog8_label_asm_6_if_end
	; source: src\fmalloc.p8:217   fmalloc_root.assigned_set(pm, &fptr.NULL);
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_freemem_get.p8_ptr
	sty  p8_fmalloc_root.p8_freemem_get.p8_ptr+1
	lda  #<p8_freemem+0
	ldy  #>p8_freemem+0
	sta  p8_fmalloc_root.p8_freemem_get.p8_result
	sty  p8_fmalloc_root.p8_freemem_get.p8_result+1
	
	jsr  p8_fmalloc_root.p8_freemem_get
	; source: src\fmalloc.p8:218   
	lda  p8_freemem
	sec
	sbc  p8_current_size
	sta  p8_freemem
	lda  p8_freemem+1
	sbc  p8_current_size+1
	sta  p8_freemem+1
	; source: src\fmalloc.p8:219   fmalloc_root.freemem_set_wi(pm, 0);
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_freemem_set.p8_ptr
	sty  p8_fmalloc_root.p8_freemem_set.p8_ptr+1
	lda  #<p8_freemem+0
	ldy  #>p8_freemem+0
	sta  p8_fmalloc_root.p8_freemem_set.p8_value
	sty  p8_fmalloc_root.p8_freemem_set.p8_value+1
	
	jsr  p8_fmalloc_root.p8_freemem_set
	; source: src\fmalloc.p8:222   
	lda  p8_current+1
	pha
	lda  p8_current+2
	tay
	pla
	sta  p8_temp_result
	sty  p8_temp_result+1
	clc
	adc  #8
	sta  p8_temp_result
	bcc  +
	inc  p8_temp_result+1
+
	; source: src\fmalloc.p8:224   
	lda  p8_current+0
	ldy  p8_result
	sty  P8ZP_SCRATCH_W1
	ldy  p8_result+1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	sta  (P8ZP_SCRATCH_W1),y
	; source: src\fmalloc.p8:225   }
	lda  p8_temp_result
	ldy  p8_result
	sty  P8ZP_SCRATCH_W1
	ldy  p8_result+1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #1
	sta  (P8ZP_SCRATCH_W1),y
	; source: src\fmalloc.p8:226   
	lda  p8_temp_result+1
	ldy  p8_result
	sty  P8ZP_SCRATCH_W1
	ldy  p8_result+1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #2
	sta  (P8ZP_SCRATCH_W1),y
	; source: src\fmalloc.p8:146   
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_current	.fill  3
p8_current_next	.fill  3
p8_current_size	.word  ?
p8_freemem	.word  ?
p8_new_size	.word  ?
p8_newfree	.fill  3
p8_pm	.word  ?
p8_result	.word  ?
p8_size	.word  ?
p8_temp_result	.word  ?
p8_totalnodes	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:229   ; DO NOT ADD THE SAME BLOCK MORE THAN ONCE!!!!

p8_free	.proc
; statements
	; source: src\fmalloc.p8:235   ; Get the usable size of the block
	; source: src\fmalloc.p8:236   
	; source: src\fmalloc.p8:244   
	; source: src\fmalloc.p8:245   uword freemem;
	; source: src\fmalloc.p8:232   
	lda  #<p8_ptr+0
	ldy  #>p8_ptr+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #0
	bne  prog8_label_asm_7_if_end
	rts
prog8_label_asm_7_if_end
	; source: src\fmalloc.p8:236   
	ldy  #1
	lda  p8_ptr
	sta  P8ZP_SCRATCH_W1
	lda  p8_ptr+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	pha
	ldy  #2
	lda  p8_ptr
	sta  P8ZP_SCRATCH_W1
	lda  p8_ptr+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	tay
	pla
	sta  p8_temp_result
	sty  p8_temp_result+1
	sec
	sbc  #8
	sta  p8_temp_result
	bcs  +
	dec  p8_temp_result+1
+
	; source: src\fmalloc.p8:237   uword usableSize = size - fmalloc_item.SIZEOF_FMALLOC_ITEM;
	ldy  #0
	lda  p8_ptr
	sta  P8ZP_SCRATCH_W1
	lda  p8_ptr+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	sta  p8_node+0
	; source: src\fmalloc.p8:238   
	lda  p8_temp_result
	sta  p8_node+1
	; source: src\fmalloc.p8:239   fmalloc_item.size_set(ptr, &usableSize)
	lda  p8_temp_result+1
	sta  p8_node+2
	; source: src\fmalloc.p8:242   
	ldy  p8_pm+1
	lda  p8_pm
	clc
	adc  #<3
	tax
	tya
	adc  #>3
	tay
	txa
	sta  p8_fmalloc.p8_remove_item.p8_root
	sty  p8_fmalloc.p8_remove_item.p8_root+1
	lda  #<p8_node+0
	ldy  #>p8_node+0
	sta  p8_fmalloc.p8_remove_item.p8_node
	sty  p8_fmalloc.p8_remove_item.p8_node+1
	
	jsr  p8_fmalloc.p8_remove_item
	; source: src\fmalloc.p8:244   
	stz  p8_freemem
	stz  p8_freemem+1
	; source: src\fmalloc.p8:245   uword freemem;
	stz  p8_node_size
	stz  p8_node_size+1
	; source: src\fmalloc.p8:246   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_freemem_get.p8_ptr
	sty  p8_fmalloc_root.p8_freemem_get.p8_ptr+1
	lda  #<p8_freemem+0
	ldy  #>p8_freemem+0
	sta  p8_fmalloc_root.p8_freemem_get.p8_result
	sty  p8_fmalloc_root.p8_freemem_get.p8_result+1
	
	jsr  p8_fmalloc_root.p8_freemem_get
	; source: src\fmalloc.p8:247   fmalloc_root.freemem_get(pm, &freemem);
	lda  #<p8_node+0
	ldy  #>p8_node+0
	sta  p8_fmalloc_item.p8_size_get.p8_ptr
	sty  p8_fmalloc_item.p8_size_get.p8_ptr+1
	
	lda  #<p8_node_size+0
	ldy  #>p8_node_size+0
	sta  p8_fmalloc_item.p8_size_get.p8_result
	sty  p8_fmalloc_item.p8_size_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_size_get
	; source: src\fmalloc.p8:248   
	lda  p8_freemem
	clc
	adc  p8_node_size
	sta  p8_freemem
	lda  p8_freemem+1
	adc  p8_node_size+1
	sta  p8_freemem+1
	; source: src\fmalloc.p8:249   freemem = freemem + usableSize;
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_freemem_set.p8_ptr
	sty  p8_fmalloc_root.p8_freemem_set.p8_ptr+1
	lda  #<p8_freemem+0
	ldy  #>p8_freemem+0
	sta  p8_fmalloc_root.p8_freemem_set.p8_value
	sty  p8_fmalloc_root.p8_freemem_set.p8_value+1
	
	jsr  p8_fmalloc_root.p8_freemem_set
	; source: src\fmalloc.p8:252   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc.p8_insert_item.p8_root
	sty  p8_fmalloc.p8_insert_item.p8_root+1
	lda  #<p8_node+0
	ldy  #>p8_node+0
	sta  p8_fmalloc.p8_insert_item.p8_node
	sty  p8_fmalloc.p8_insert_item.p8_node+1
	
	jsr  p8_fmalloc.p8_insert_item
	; source: src\fmalloc.p8:255   uword totalmem;
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc.p8_merge.p8_pm
	sty  p8_fmalloc.p8_merge.p8_pm+1
	lda  #<p8_node+0
	ldy  #>p8_node+0
	sta  p8_fmalloc.p8_merge.p8_node
	sty  p8_fmalloc.p8_merge.p8_node+1
	
	jmp  p8_fmalloc.p8_merge
	; source: src\fmalloc.p8:229   ; DO NOT ADD THE SAME BLOCK MORE THAN ONCE!!!!
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_freemem	.word  ?
p8_node	.fill  3
p8_node_size	.word  ?
p8_pm	.word  ?
p8_ptr	.word  ?
p8_temp_result	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:258   

p8_merge	.proc
; statements
	; source: src\fmalloc.p8:306   
	; source: src\fmalloc.p8:299   uword temp_result;
	; source: src\fmalloc.p8:297   uword freemem;
	; source: src\fmalloc.p8:295   uword current_size;
	; source: src\fmalloc.p8:259   totalmem = totalmem + usableSize;
	; source: src\fmalloc.p8:260   
	; source: src\fmalloc.p8:261   fmalloc_root.totalmem_set(pm, &totalmem);
	; source: src\fmalloc.p8:262   
	; source: src\fmalloc.p8:263   
	; source: src\fmalloc.p8:264   
	; source: src\fmalloc.p8:306   
	stz  p8_totalnodes
	stz  p8_totalnodes+1
	; source: src\fmalloc.p8:299   uword temp_result;
	stz  p8_freemem
	stz  p8_freemem+1
	; source: src\fmalloc.p8:295   uword current_size;
	stz  p8_node_next_size
	stz  p8_node_next_size+1
	; source: src\fmalloc.p8:260   
	stz  p8_node_prev_size
	stz  p8_node_prev_size+1
	; source: src\fmalloc.p8:262   
	stz  p8_node_size
	stz  p8_node_size+1
	; source: src\fmalloc.p8:263   
	stz  p8_temp_result
	stz  p8_temp_result+1
	; source: src\fmalloc.p8:267   insert_item(pm + fmalloc_root.FMALLOC_available, ptr);
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_prev_get.p8_ptr
	sty  p8_fmalloc_item.p8_prev_get.p8_ptr+1
	lda  #<p8_node_prev+0
	ldy  #>p8_node_prev+0
	sta  p8_fmalloc_item.p8_prev_get.p8_result
	sty  p8_fmalloc_item.p8_prev_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_prev_get
	; source: src\fmalloc.p8:268   
	lda  #<p8_node_prev+0
	ldy  #>p8_node_prev+0
	sta  p8_fmalloc_item.p8_size_get.p8_ptr
	sty  p8_fmalloc_item.p8_size_get.p8_ptr+1
	
	lda  #<p8_node_prev_size+0
	ldy  #>p8_node_prev_size+0
	sta  p8_fmalloc_item.p8_size_get.p8_result
	sty  p8_fmalloc_item.p8_size_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_size_get
	; source: src\fmalloc.p8:269   
	lda  p8_node_prev+1
	pha
	lda  p8_node_prev+2
	tay
	pla
	clc
	adc  #<8
	tax
	tya
	adc  #>8
	tay
	txa
	clc
	adc  p8_node_prev_size
	tax
	tya
	adc  p8_node_prev_size+1
	tay
	txa
	sta  p8_temp_result
	sty  p8_temp_result+1
	; source: src\fmalloc.p8:270   
	lda  p8_node_prev+0
	sta  p8_temp_ptr+0
	; source: src\fmalloc.p8:271   ; update totalnodes
	lda  p8_temp_result
	sta  p8_temp_ptr+1
	; source: src\fmalloc.p8:272   
	lda  p8_temp_result+1
	sta  p8_temp_ptr+2
	; source: src\fmalloc.p8:274   
p8_prog8_label_7_whileloop
	lda  #<p8_node_prev+0
	ldy  #>p8_node_prev+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	beq  +
	lda  #1
+
	pha
	lda  #<p8_node+0
	ldy  #>p8_node+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_temp_ptr+0
	ldy  #>p8_temp_ptr+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	beq  +
	lda  #1
+
	sta  P8ZP_SCRATCH_B1
	pla
	and  P8ZP_SCRATCH_B1
	beq  p8_prog8_label_8_afterwhile
	; source: src\fmalloc.p8:275   fmalloc_root.totalnodes_get(pm, &totalnodes);
	lda  p8_node_prev+0
	ldy  p8_node
	sty  P8ZP_SCRATCH_W1
	ldy  p8_node+1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	sta  (P8ZP_SCRATCH_W1),y
	; source: src\fmalloc.p8:276   
	lda  p8_node_prev+1
	ldy  p8_node
	sty  P8ZP_SCRATCH_W1
	ldy  p8_node+1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #1
	sta  (P8ZP_SCRATCH_W1),y
	; source: src\fmalloc.p8:277   totalnodes++;
	lda  p8_node_prev+2
	ldy  p8_node
	sty  P8ZP_SCRATCH_W1
	ldy  p8_node+1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #2
	sta  (P8ZP_SCRATCH_W1),y
	; source: src\fmalloc.p8:278   
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_prev_get.p8_ptr
	sty  p8_fmalloc_item.p8_prev_get.p8_ptr+1
	lda  #<p8_node_prev+0
	ldy  #>p8_node_prev+0
	sta  p8_fmalloc_item.p8_prev_get.p8_result
	sty  p8_fmalloc_item.p8_prev_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_prev_get
	; source: src\fmalloc.p8:279   fmalloc_root.totalnodes_set(pm, &totalnodes);
	lda  #<p8_node_prev+0
	ldy  #>p8_node_prev+0
	sta  p8_fmalloc_item.p8_size_get.p8_ptr
	sty  p8_fmalloc_item.p8_size_get.p8_ptr+1
	
	lda  #<p8_node_prev_size+0
	ldy  #>p8_node_prev_size+0
	sta  p8_fmalloc_item.p8_size_get.p8_result
	sty  p8_fmalloc_item.p8_size_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_size_get
	; source: src\fmalloc.p8:280   
	lda  p8_node_prev+1
	pha
	lda  p8_node_prev+2
	tay
	pla
	clc
	adc  #<8
	tax
	tya
	adc  #>8
	tay
	txa
	clc
	adc  p8_node_prev_size
	tax
	tya
	adc  p8_node_prev_size+1
	tay
	txa
	sta  p8_temp_result
	sty  p8_temp_result+1
	; source: src\fmalloc.p8:281   
	lda  p8_node_prev+0
	sta  p8_temp_ptr+0
	; source: src\fmalloc.p8:282   
	lda  p8_temp_result
	sta  p8_temp_ptr+1
	; source: src\fmalloc.p8:283   ;dump_fmalloc(pm);
	lda  p8_temp_result+1
	sta  p8_temp_ptr+2
	; source: src\fmalloc.p8:274   
	bra  p8_prog8_label_7_whileloop
p8_prog8_label_8_afterwhile
	; source: src\fmalloc.p8:287   }
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_next_get.p8_ptr
	sty  p8_fmalloc_item.p8_next_get.p8_ptr+1
	lda  #<p8_node_next+0
	ldy  #>p8_node_next+0
	sta  p8_fmalloc_item.p8_next_get.p8_result
	sty  p8_fmalloc_item.p8_next_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_next_get
	; source: src\fmalloc.p8:288   
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_size_get.p8_ptr
	sty  p8_fmalloc_item.p8_size_get.p8_ptr+1
	lda  #<p8_node_size+0
	ldy  #>p8_node_size+0
	sta  p8_fmalloc_item.p8_size_get.p8_result
	sty  p8_fmalloc_item.p8_size_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_size_get
	; source: src\fmalloc.p8:289   
	ldy  #1
	lda  p8_node
	sta  P8ZP_SCRATCH_W1
	lda  p8_node+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	pha
	ldy  #2
	lda  p8_node
	sta  P8ZP_SCRATCH_W1
	lda  p8_node+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	tay
	pla
	clc
	adc  #<8
	tax
	tya
	adc  #>8
	tay
	txa
	clc
	adc  p8_node_size
	tax
	tya
	adc  p8_node_size+1
	tay
	txa
	sta  p8_temp_result
	sty  p8_temp_result+1
	; source: src\fmalloc.p8:290   
	ldy  #0
	lda  p8_node
	sta  P8ZP_SCRATCH_W1
	lda  p8_node+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	sta  p8_temp_ptr+0
	; source: src\fmalloc.p8:291   sub malloc(uword pm, uword size, ubyte[fptr.SIZEOF_FPTR] result)   {
	lda  p8_temp_result
	sta  p8_temp_ptr+1
	; source: src\fmalloc.p8:292   
	lda  p8_temp_result+1
	sta  p8_temp_ptr+2
	; source: src\fmalloc.p8:294   
p8_prog8_label_9_whileloop
	lda  #<p8_node_next+0
	ldy  #>p8_node_next+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_temp_ptr+0
	ldy  #>p8_temp_ptr+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #0
	bne  p8_prog8_label_10_afterwhile
	; source: src\fmalloc.p8:296   
	lda  #<p8_node_next+0
	ldy  #>p8_node_next+0
	sta  p8_fmalloc_item.p8_size_get.p8_ptr
	sty  p8_fmalloc_item.p8_size_get.p8_ptr+1
	
	lda  #<p8_node_next_size+0
	ldy  #>p8_node_next_size+0
	sta  p8_fmalloc_item.p8_size_get.p8_result
	sty  p8_fmalloc_item.p8_size_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_size_get
	; source: src\fmalloc.p8:297   uword freemem;
	lda  p8_node_next_size
	ldy  p8_node_next_size+1
	sta  p8_temp_node_size
	sty  p8_temp_node_size+1
	clc
	adc  #8
	sta  p8_temp_node_size
	bcc  +
	inc  p8_temp_node_size+1
+
	; source: src\fmalloc.p8:300   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_freemem_get.p8_ptr
	sty  p8_fmalloc_root.p8_freemem_get.p8_ptr+1
	lda  #<p8_freemem+0
	ldy  #>p8_freemem+0
	sta  p8_fmalloc_root.p8_freemem_get.p8_result
	sty  p8_fmalloc_root.p8_freemem_get.p8_result+1
	
	jsr  p8_fmalloc_root.p8_freemem_get
	; source: src\fmalloc.p8:301   
	lda  p8_freemem
	clc
	adc  #8
	sta  p8_freemem
	bcc  +
	inc  p8_freemem+1
+
	; source: src\fmalloc.p8:302   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_freemem_set.p8_ptr
	sty  p8_fmalloc_root.p8_freemem_set.p8_ptr+1
	lda  #<p8_freemem+0
	ldy  #>p8_freemem+0
	sta  p8_fmalloc_root.p8_freemem_set.p8_value
	sty  p8_fmalloc_root.p8_freemem_set.p8_value+1
	
	jsr  p8_fmalloc_root.p8_freemem_set
	; source: src\fmalloc.p8:304   
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc.p8_remove_item.p8_root
	sty  p8_fmalloc.p8_remove_item.p8_root+1
	lda  #<p8_node_next+0
	ldy  #>p8_node_next+0
	sta  p8_fmalloc.p8_remove_item.p8_node
	sty  p8_fmalloc.p8_remove_item.p8_node+1
	
	jsr  p8_fmalloc.p8_remove_item
	; source: src\fmalloc.p8:307   size = (size + 7) & -8;
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_totalnodes_get.p8_ptr
	sty  p8_fmalloc_root.p8_totalnodes_get.p8_ptr+1
	lda  #<p8_totalnodes+0
	ldy  #>p8_totalnodes+0
	sta  p8_fmalloc_root.p8_totalnodes_get.p8_result
	sty  p8_fmalloc_root.p8_totalnodes_get.p8_result+1
	
	jsr  p8_fmalloc_root.p8_totalnodes_get
	; source: src\fmalloc.p8:308   
	lda  p8_totalnodes
	bne  +
	dec  p8_totalnodes+1
+       dec  p8_totalnodes 
	; source: src\fmalloc.p8:309   size -= fmalloc_item.SIZEOF_FMALLOC_ITEM
	lda  p8_pm
	ldy  p8_pm+1
	sta  p8_fmalloc_root.p8_totalnodes_set.p8_ptr
	sty  p8_fmalloc_root.p8_totalnodes_set.p8_ptr+1
	lda  #<p8_totalnodes+0
	ldy  #>p8_totalnodes+0
	sta  p8_fmalloc_root.p8_totalnodes_set.p8_value
	sty  p8_fmalloc_root.p8_totalnodes_set.p8_value+1
	
	jsr  p8_fmalloc_root.p8_totalnodes_set
	; source: src\fmalloc.p8:311   
	lda  p8_node_size
	clc
	adc  p8_temp_node_size
	sta  p8_node_size
	lda  p8_node_size+1
	adc  p8_temp_node_size+1
	sta  p8_node_size+1
	; source: src\fmalloc.p8:312   
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_size_set.p8_ptr
	sty  p8_fmalloc_item.p8_size_set.p8_ptr+1
	lda  #<p8_node_size+0
	ldy  #>p8_node_size+0
	sta  p8_fmalloc_item.p8_size_set.p8_value
	sty  p8_fmalloc_item.p8_size_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_size_set
	; source: src\fmalloc.p8:314   
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_next_get.p8_ptr
	sty  p8_fmalloc_item.p8_next_get.p8_ptr+1
	lda  #<p8_node_next+0
	ldy  #>p8_node_next+0
	sta  p8_fmalloc_item.p8_next_get.p8_result
	sty  p8_fmalloc_item.p8_next_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_next_get
	; source: src\fmalloc.p8:315   fmalloc_root.available_get(pm, &current)
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_size_get.p8_ptr
	sty  p8_fmalloc_item.p8_size_get.p8_ptr+1
	lda  #<p8_node_size+0
	ldy  #>p8_node_size+0
	sta  p8_fmalloc_item.p8_size_get.p8_result
	sty  p8_fmalloc_item.p8_size_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_size_get
	; source: src\fmalloc.p8:316   
	ldy  #1
	lda  p8_node
	sta  P8ZP_SCRATCH_W1
	lda  p8_node+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	pha
	ldy  #2
	lda  p8_node
	sta  P8ZP_SCRATCH_W1
	lda  p8_node+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	tay
	pla
	clc
	adc  #<8
	tax
	tya
	adc  #>8
	tay
	txa
	clc
	adc  p8_node_size
	tax
	tya
	adc  p8_node_size+1
	tay
	txa
	sta  p8_temp_result
	sty  p8_temp_result+1
	; source: src\fmalloc.p8:317   fmalloc_item.size_get(current, &current_size);
	ldy  #0
	lda  p8_node
	sta  P8ZP_SCRATCH_W1
	lda  p8_node+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	sta  p8_temp_ptr+0
	; source: src\fmalloc.p8:318   
	lda  p8_temp_result
	sta  p8_temp_ptr+1
	; source: src\fmalloc.p8:319   while (fptr.compare(&current, &fptr.NULL) != fptr.compare_equal) and (current_size < size) {
	lda  p8_temp_result+1
	sta  p8_temp_ptr+2
	; source: src\fmalloc.p8:294   
	bra  p8_prog8_label_9_whileloop
p8_prog8_label_10_afterwhile
	; source: src\fmalloc.p8:258   
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_freemem	.word  ?
p8_node	.word  ?
p8_node_next	.fill  3
p8_node_next_size	.word  ?
p8_node_prev	.fill  3
p8_node_prev_size	.word  ?
p8_node_size	.word  ?
p8_pm	.word  ?
p8_temp_node_size	.word  ?
p8_temp_ptr	.fill  3
p8_temp_result	.word  ?
p8_totalnodes	.word  ?
	.send BSS
	.pend
	; source: src\fmalloc.p8:324   

p8_insert_item	.proc
; statements
	; source: src\fmalloc.p8:354   
	; source: src\fmalloc.p8:353   
	; source: src\fmalloc.p8:373   uword new_size = current_size - fmalloc_item.SIZEOF_FMALLOC_ITEM - size;
	; source: src\fmalloc.p8:341   
	; source: src\fmalloc.p8:325   }
	; source: src\fmalloc.p8:326   
	lda  p8_root
	sta  cx16.r0
	lda  p8_root+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  #<p8_xRoot+0
	sta  cx16.r1
	lda  #>p8_xRoot+0
	sta  cx16.r1+1
	
	ldx  #3
	jsr  p8_struct.p8_get
	; source: src\fmalloc.p8:329   ; If there's nothing suitable, we're either out of memory or fragged.
	lda  #<p8_xRoot+0
	ldy  #>p8_xRoot+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #0
	bne  prog8_label_asm_8_if_end
	; source: src\fmalloc.p8:330   
	ldy  #0
	lda  p8_node
	sta  P8ZP_SCRATCH_W1
	lda  p8_node+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	sta  p8_xRoot+0
	; source: src\fmalloc.p8:331   if fptr.compare(&current, &fptr.NULL) == fptr.compare_equal {
	ldy  #1
	lda  p8_node
	sta  P8ZP_SCRATCH_W1
	lda  p8_node+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	sta  p8_xRoot+1
	; source: src\fmalloc.p8:332   
	ldy  #2
	lda  p8_node
	sta  P8ZP_SCRATCH_W1
	lda  p8_node+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	sta  p8_xRoot+2
	; source: src\fmalloc.p8:333   result[0] = 0;
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_prev_set.p8_ptr
	sty  p8_fmalloc_item.p8_prev_set.p8_ptr+1
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fmalloc_item.p8_prev_set.p8_value
	sty  p8_fmalloc_item.p8_prev_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_prev_set
	; source: src\fmalloc.p8:334   
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_next_set.p8_ptr
	sty  p8_fmalloc_item.p8_next_set.p8_ptr+1
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fmalloc_item.p8_next_set.p8_value
	sty  p8_fmalloc_item.p8_next_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_next_set
	; source: src\fmalloc.p8:335   result[1] = 0;
	lda  p8_root
	sta  cx16.r0
	lda  p8_root+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  #<p8_xRoot+0
	sta  cx16.r1
	lda  #>p8_xRoot+0
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_struct.p8_set
	; source: src\fmalloc.p8:336   
prog8_label_asm_8_if_end
	; source: src\fmalloc.p8:340   
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	lda  #<p8_xRoot+0
	ldy  #>p8_xRoot+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #-1
	bne  prog8_label_asm_9_if_else
	; source: src\fmalloc.p8:342   
	lda  #<p8_xRoot+0
	sta  cx16.r0
	lda  #>p8_xRoot+0
	sta  cx16.r0+1
	
	lda  #<p8_oldroot+0
	sta  cx16.r1
	lda  #>p8_oldroot+0
	sta  cx16.r1+1
	
	ldy  #>3
	lda  #<3
	jsr  sys.memcopy
	; source: src\fmalloc.p8:343   ; Remove it from pm->available
	lda  #<p8_oldroot+0
	ldy  #>p8_oldroot+0
	sta  p8_fmalloc_item.p8_prev_set.p8_ptr
	sty  p8_fmalloc_item.p8_prev_set.p8_ptr+1
	
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_prev_set.p8_value
	sty  p8_fmalloc_item.p8_prev_set.p8_value+1
	jsr  p8_fmalloc_item.p8_prev_set
	; source: src\fmalloc.p8:344   
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_next_set.p8_ptr
	sty  p8_fmalloc_item.p8_next_set.p8_ptr+1
	lda  #<p8_oldroot+0
	ldy  #>p8_oldroot+0
	sta  p8_fmalloc_item.p8_next_set.p8_value
	sty  p8_fmalloc_item.p8_next_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_next_set
	; source: src\fmalloc.p8:345   remove_item(pm + fmalloc_root.FMALLOC_available, current);
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_prev_set.p8_ptr
	sty  p8_fmalloc_item.p8_prev_set.p8_ptr+1
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fmalloc_item.p8_prev_set.p8_value
	sty  p8_fmalloc_item.p8_prev_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_prev_set
	; source: src\fmalloc.p8:346   
	ldy  #0
	lda  p8_node
	sta  P8ZP_SCRATCH_W1
	lda  p8_node+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	sta  p8_xRoot+0
	; source: src\fmalloc.p8:347   
	ldy  #1
	lda  p8_node
	sta  P8ZP_SCRATCH_W1
	lda  p8_node+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	sta  p8_xRoot+1
	; source: src\fmalloc.p8:348   
	ldy  #2
	lda  p8_node
	sta  P8ZP_SCRATCH_W1
	lda  p8_node+1
	sta  P8ZP_SCRATCH_W1+1
	lda  (P8ZP_SCRATCH_W1),y
	sta  p8_xRoot+2
	; source: src\fmalloc.p8:350   
	lda  p8_root
	sta  cx16.r0
	lda  p8_root+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  #<p8_xRoot+0
	sta  cx16.r1
	lda  #>p8_xRoot+0
	sta  cx16.r1+1
	
	ldx  #3
	jsr  p8_struct.p8_set
	bra  prog8_label_asm_10_if_end
prog8_label_asm_9_if_else
	; source: src\fmalloc.p8:356   
	lda  #<p8_xRoot+0
	sta  cx16.r0
	lda  #>p8_xRoot+0
	sta  cx16.r0+1
	
	lda  #<p8_current+0
	sta  cx16.r1
	lda  #>p8_current+0
	sta  cx16.r1+1
	
	ldy  #>3
	lda  #<3
	jsr  sys.memcopy
	; source: src\fmalloc.p8:359   
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_next_get.p8_ptr
	sty  p8_fmalloc_item.p8_next_get.p8_ptr+1
	
	lda  #<p8_current_next+0
	ldy  #>p8_current_next+0
	sta  p8_fmalloc_item.p8_next_get.p8_result
	sty  p8_fmalloc_item.p8_next_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_next_get
	; source: src\fmalloc.p8:361   ; Add a free block that's the remainder size
p8_prog8_label_11_whileloop
	lda  #<p8_current_next+0
	ldy  #>p8_current_next+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	beq  +
	lda  #1
+
	pha
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	lda  #<p8_current_next+0
	ldy  #>p8_current_next+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #1
	beq  +
	lda  #0
	beq  ++
+                   lda  #1
+
	sta  P8ZP_SCRATCH_B1
	pla
	and  P8ZP_SCRATCH_B1
	beq  p8_prog8_label_12_afterwhile
	; source: src\fmalloc.p8:362   
	lda  #<p8_current_next+0
	sta  cx16.r0
	lda  #>p8_current_next+0
	sta  cx16.r0+1
	
	lda  #<p8_current+0
	sta  cx16.r1
	lda  #>p8_current+0
	sta  cx16.r1+1
	
	ldy  #>3
	lda  #<3
	jsr  sys.memcopy
	; source: src\fmalloc.p8:363   ubyte[fptr.SIZEOF_FPTR] newfree;
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_next_get.p8_ptr
	sty  p8_fmalloc_item.p8_next_get.p8_ptr+1
	
	lda  #<p8_current_next+0
	ldy  #>p8_current_next+0
	sta  p8_fmalloc_item.p8_next_get.p8_result
	sty  p8_fmalloc_item.p8_next_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_next_get
	; source: src\fmalloc.p8:361   ; Add a free block that's the remainder size
	bra  p8_prog8_label_11_whileloop
p8_prog8_label_12_afterwhile
	; source: src\fmalloc.p8:367   newfree[0] = current[0];
	lda  #<p8_current_next+0
	ldy  #>p8_current_next+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #0
	bne  prog8_label_asm_11_if_else
	; source: src\fmalloc.p8:368   
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_prev_set.p8_ptr
	sty  p8_fmalloc_item.p8_prev_set.p8_ptr+1
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_prev_set.p8_value
	sty  p8_fmalloc_item.p8_prev_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_prev_set
	; source: src\fmalloc.p8:369   newfree[1] = lsb(temp_result);
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_next_set.p8_ptr
	sty  p8_fmalloc_item.p8_next_set.p8_ptr+1
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fmalloc_item.p8_next_set.p8_value
	sty  p8_fmalloc_item.p8_next_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_next_set
	; source: src\fmalloc.p8:370   
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_next_set.p8_ptr
	sty  p8_fmalloc_item.p8_next_set.p8_ptr+1
	
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_next_set.p8_value
	sty  p8_fmalloc_item.p8_next_set.p8_value+1
	jsr  p8_fmalloc_item.p8_next_set
	bra  prog8_label_asm_12_if_end
prog8_label_asm_11_if_else
	; source: src\fmalloc.p8:374   
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_next_get.p8_ptr
	sty  p8_fmalloc_item.p8_next_get.p8_ptr+1
	
	lda  #<p8_oldnext+0
	ldy  #>p8_oldnext+0
	sta  p8_fmalloc_item.p8_next_get.p8_result
	sty  p8_fmalloc_item.p8_next_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_next_get
	; source: src\fmalloc.p8:375   fmalloc_item.size_set(newfree, &new_size)
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_next_set.p8_ptr
	sty  p8_fmalloc_item.p8_next_set.p8_ptr+1
	
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_next_set.p8_value
	sty  p8_fmalloc_item.p8_next_set.p8_value+1
	jsr  p8_fmalloc_item.p8_next_set
	; source: src\fmalloc.p8:376   
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_prev_set.p8_ptr
	sty  p8_fmalloc_item.p8_prev_set.p8_ptr+1
	lda  #<p8_current+0
	ldy  #>p8_current+0
	sta  p8_fmalloc_item.p8_prev_set.p8_value
	sty  p8_fmalloc_item.p8_prev_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_prev_set
	; source: src\fmalloc.p8:377   ubyte[fptr.SIZEOF_FPTR] current_next;
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_next_set.p8_ptr
	sty  p8_fmalloc_item.p8_next_set.p8_ptr+1
	lda  #<p8_oldnext+0
	ldy  #>p8_oldnext+0
	sta  p8_fmalloc_item.p8_next_set.p8_value
	sty  p8_fmalloc_item.p8_next_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_next_set
	; source: src\fmalloc.p8:378   
	lda  #<p8_oldnext+0
	ldy  #>p8_oldnext+0
	sta  p8_fmalloc_item.p8_prev_set.p8_ptr
	sty  p8_fmalloc_item.p8_prev_set.p8_ptr+1
	
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_prev_set.p8_value
	sty  p8_fmalloc_item.p8_prev_set.p8_value+1
	jsr  p8_fmalloc_item.p8_prev_set
prog8_label_asm_12_if_end
prog8_label_asm_10_if_end
	; source: src\fmalloc.p8:324   
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_current	.fill  3
p8_current_next	.fill  3
p8_node	.word  ?
p8_oldnext	.fill  3
p8_oldroot	.fill  3
p8_root	.word  ?
p8_xRoot	.fill  3
	.send BSS
	.pend
	; source: src\fmalloc.p8:384   

p8_remove_item	.proc
; statements
	; source: src\fmalloc.p8:385   
	; source: src\fmalloc.p8:386   
	; source: src\fmalloc.p8:387   ; Change pm->assigned size
	; source: src\fmalloc.p8:389   current_size = size;
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_next_get.p8_ptr
	sty  p8_fmalloc_item.p8_next_get.p8_ptr+1
	lda  #<p8_node_next+0
	ldy  #>p8_node_next+0
	sta  p8_fmalloc_item.p8_next_get.p8_result
	sty  p8_fmalloc_item.p8_next_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_next_get
	; source: src\fmalloc.p8:390   
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_prev_get.p8_ptr
	sty  p8_fmalloc_item.p8_prev_get.p8_ptr+1
	lda  #<p8_node_prev+0
	ldy  #>p8_node_prev+0
	sta  p8_fmalloc_item.p8_prev_get.p8_result
	sty  p8_fmalloc_item.p8_prev_get.p8_result+1
	
	jsr  p8_fmalloc_item.p8_prev_get
	; source: src\fmalloc.p8:391   fmalloc_item.size_set(current, &current_size);
	lda  p8_root
	sta  cx16.r0
	lda  p8_root+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  #<p8_xRoot+0
	sta  cx16.r1
	lda  #>p8_xRoot+0
	sta  cx16.r1+1
	
	ldx  #3
	jsr  p8_struct.p8_get
	; source: src\fmalloc.p8:394   
	lda  #<p8_node_prev+0
	ldy  #>p8_node_prev+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #0
	beq  prog8_label_asm_13_if_end
	; source: src\fmalloc.p8:395   ; Put the new block back into the available list
	lda  #<p8_node_prev+0
	ldy  #>p8_node_prev+0
	sta  p8_fmalloc_item.p8_next_set.p8_ptr
	sty  p8_fmalloc_item.p8_next_set.p8_ptr+1
	
	lda  #<p8_node_next+0
	ldy  #>p8_node_next+0
	sta  p8_fmalloc_item.p8_next_set.p8_value
	sty  p8_fmalloc_item.p8_next_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_next_set
prog8_label_asm_13_if_end
	; source: src\fmalloc.p8:397   insert_item(pm + fmalloc_root.FMALLOC_available, newfree);
	lda  #<p8_node_next+0
	ldy  #>p8_node_next+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #0
	beq  prog8_label_asm_14_if_end
	; source: src\fmalloc.p8:398   
	lda  #<p8_node_next+0
	ldy  #>p8_node_next+0
	sta  p8_fmalloc_item.p8_prev_set.p8_ptr
	sty  p8_fmalloc_item.p8_prev_set.p8_ptr+1
	
	lda  #<p8_node_prev+0
	ldy  #>p8_node_prev+0
	sta  p8_fmalloc_item.p8_prev_set.p8_value
	sty  p8_fmalloc_item.p8_prev_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_prev_set
prog8_label_asm_14_if_end
	; source: src\fmalloc.p8:402   
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	lda  #<p8_xRoot+0
	ldy  #>p8_xRoot+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #0
	bne  prog8_label_asm_15_if_end
	; source: src\fmalloc.p8:403   fmalloc_root.freemem_get(pm, &freemem);
	lda  #<p8_node_prev+0
	ldy  #>p8_node_prev+0
	sta  p8_fptr.p8_compare.p8_ptr1
	sty  p8_fptr.p8_compare.p8_ptr1+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fptr.p8_compare.p8_ptr2
	sty  p8_fptr.p8_compare.p8_ptr2+1
	
	jsr  p8_fptr.p8_compare
	cmp  #0
	beq  prog8_label_asm_16_if_else
	; source: src\fmalloc.p8:404   
	lda  #<p8_node_prev+0
	sta  cx16.r0
	lda  #>p8_node_prev+0
	sta  cx16.r0+1
	
	lda  #<p8_xRoot+0
	sta  cx16.r1
	lda  #>p8_xRoot+0
	sta  cx16.r1+1
	
	ldy  #>3
	lda  #<3
	jsr  sys.memcopy
	bra  prog8_label_asm_17_if_end
prog8_label_asm_16_if_else
	; source: src\fmalloc.p8:406   
	lda  #<p8_node_next+0
	sta  cx16.r0
	lda  #>p8_node_next+0
	sta  cx16.r0+1
	
	lda  #<p8_xRoot+0
	sta  cx16.r1
	lda  #>p8_xRoot+0
	sta  cx16.r1+1
	
	ldy  #>3
	lda  #<3
	jsr  sys.memcopy
prog8_label_asm_17_if_end
	; source: src\fmalloc.p8:408   
	lda  p8_root
	sta  cx16.r0
	lda  p8_root+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  #<p8_xRoot+0
	sta  cx16.r1
	lda  #>p8_xRoot+0
	sta  cx16.r1+1
	
	ldx  #3
	jsr  p8_struct.p8_set
prog8_label_asm_15_if_end
	; source: src\fmalloc.p8:412   
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_next_set.p8_ptr
	sty  p8_fmalloc_item.p8_next_set.p8_ptr+1
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fmalloc_item.p8_next_set.p8_value
	sty  p8_fmalloc_item.p8_next_set.p8_value+1
	
	jsr  p8_fmalloc_item.p8_next_set
	; source: src\fmalloc.p8:413   uword totalnodes;
	lda  p8_node
	ldy  p8_node+1
	sta  p8_fmalloc_item.p8_prev_set.p8_ptr
	sty  p8_fmalloc_item.p8_prev_set.p8_ptr+1
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_fmalloc_item.p8_prev_set.p8_value
	sty  p8_fmalloc_item.p8_prev_set.p8_value+1
	
	jmp  p8_fmalloc_item.p8_prev_set
	; source: src\fmalloc.p8:384   
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_node	.word  ?
p8_node_next	.fill  3
p8_node_prev	.fill  3
p8_root	.word  ?
p8_xRoot	.fill  3
	.send BSS
	.pend
	.pend

; ---- block: 'p8_struct' ----
p8_struct	.proc
	; source: src\struct.p8:1   struct {


	; source: src\struct.p8:3   asmsub set(uword pointer @R0, ubyte offset @R2, ubyte count @X, uword valuePointer @R1) {

p8_set	.proc
	; source: src\struct.p8:4   %asm {{
           
    - 
    ldy cx16.r2H
    lda(cx16.r1),y
    ldy cx16.r2L
    sta(cx16.r0),y    
    inc cx16.r2L
    inc cx16.r2H
    dex
    bne -
  rts
	.pend
	; source: src\struct.p8:17   asmsub get(uword pointer @R0, ubyte offset @R2, ubyte count @X, uword valuePointer @R1) {

p8_get	.proc
	; source: src\struct.p8:18   %asm {{
         
    - 
    ldy cx16.r2L
    lda(cx16.r0),y
    ldy cx16.r2H
    sta(cx16.r1),y    
    inc cx16.r2L
    inc cx16.r2H
    dex
    bne -
  rts
	.pend
	; source: src\struct.p8:32   asmsub set_w(uword pointer @R0, ubyte offset @Y, uword valuePointer @R1) {

p8_set_w	.proc
	; source: src\struct.p8:33   %asm {{
   
    phy 
    ldy #$00
    lda(cx16.r1),y
    ply
    sta(cx16.r0),y    
    iny
    phy
    ldy #$01    
    lda(cx16.r1),y
    ply
    sta(cx16.r0),y
  rts
	.pend
	; source: src\struct.p8:48   asmsub set_wi(uword pointer @R0, ubyte offset @Y, uword value @R1) {

p8_set_wi	.proc
	; source: src\struct.p8:49   %asm {{
   
    lda cx16.r1
    sta(cx16.r0),y
    iny
    lda cx16.r1 + 1
    sta(cx16.r0),y
  rts
	.pend
	; source: src\struct.p8:58   asmsub get_w(uword pointer @R0, ubyte offset @Y, uword valuePointer @R1) {

p8_get_w	.proc
	; source: src\struct.p8:59   %asm {{
                    
    lda(cx16.r0),y        
    phy
    ldy #$00
    sta(cx16.r1),y
    ply
    iny
    lda(cx16.r0),y        
    ldy #$01
    sta(cx16.r1),y
  rts
	.pend
	.pend

; ---- block: 'p8_fstruct' ----
p8_fstruct	.proc
	; source: src\fstruct.p8:1   fstruct {


	; source: src\fstruct.p8:3   asmsub set_zfp(uword pointer @R0, ubyte offset @R2) {

p8_set_zfp	.proc
	; source: src\fstruct.p8:4   %asm{{
      
    ; Set Bank and extract pointer
    ldy #$00
    lda (cx16.r0),y
    sta $00       
    iny
    lda (cx16.r0),y
    sta cx16.r3L
    iny
    lda (cx16.r0),y
    sta cx16.r3H    
    
    lda #$00
    ldy cx16.r2L        
    sta (cx16.r3), y
    iny
    sta (cx16.r3), y
    iny
    sta (cx16.r3), y
  rts
	.pend
	; source: src\fstruct.p8:27   asmsub set(uword pointer @R0, ubyte offset @R2, ubyte count @X, uword valuePointer @R1) {

p8_set	.proc
	; source: src\fstruct.p8:28   %asm {{
    ; Set Bank and extract pointer
    ldy #$00
    lda (cx16.r0),y
    sta $00       
    iny
    lda (cx16.r0),y
    sta cx16.r3L
    iny
    lda (cx16.r0),y
    sta cx16.r3H            
    ; Move the bytes from @R1 to @R3
    - 
    ldy cx16.r2H
    lda(cx16.r1),y
    ldy cx16.r2L
    sta(cx16.r3),y    
    inc cx16.r2L
    inc cx16.r2H
    dex
    bne -
  rts
	.pend
	; source: src\fstruct.p8:52   asmsub get(uword pointer @R0, ubyte offset @R2, ubyte count @X, uword valuePointer @R1) {

p8_get	.proc
	; source: src\fstruct.p8:53   %asm {{
     
    ; Set Bank and extract pointer
    ldy #$00
    lda (cx16.r0),y
    sta $00       
    iny
    lda (cx16.r0),y
    sta cx16.r3L
    iny
    lda (cx16.r0),y
    sta cx16.r3H      
    ; Move the bytes from @R3 to @R1
    - 
    ldy cx16.r2L
    lda(cx16.r3),y
    ldy cx16.r2H
    sta(cx16.r1),y    
    inc cx16.r2L
    inc cx16.r2H
    dex
    bne -
  rts
	.pend
	; source: src\fstruct.p8:77   asmsub set_w(uword fptr @R0, ubyte offset @Y, uword valuePointer @R1) {

p8_set_w	.proc
	; source: src\fstruct.p8:78   %asm {{
 
    phy
    
    ; Set Bank and extract pointer
    ldy #$00
    lda (cx16.r0),y
    sta $00       
    iny
    lda (cx16.r0),y
    sta cx16.r2L
    iny
    lda (cx16.r0),y
    sta cx16.r2H  

    ; @R2->Y = *@R1 
    ldy #$00
    lda(cx16.r1),y
    ply
    sta(cx16.r2),y    
    iny
    phy
    ldy #$01    
    lda(cx16.r1),y
    ply
    sta(cx16.r2),y
  rts
	.pend
	; source: src\fstruct.p8:107   asmsub set_wi(uword fptr @R0, ubyte offset @Y, uword valuePointer @R1) {

p8_set_wi	.proc
	; source: src\fstruct.p8:108   %asm {{
 
    
    phy  

    ; Set Bank and extract pointer
    ldy #$00
    lda (cx16.r0),y
    sta $00       
    iny
    lda (cx16.r0),y
    sta cx16.r2L
    iny
    lda (cx16.r0),y
    sta cx16.r2H  

    ; @R2->Y = @R1
    ply    
    lda cx16.r1
    sta(cx16.r2),y
    iny
    lda cx16.r1 + 1
    sta(cx16.r2),y
  rts
	.pend
	; source: src\fstruct.p8:134   asmsub get_w(uword fptr @R0, ubyte offset @Y, uword valuePointer @R1) {

p8_get_w	.proc
	; source: src\fstruct.p8:135   %asm {{
    phy

    ; Set Bank and extract pointer
    ldy #$00
    lda (cx16.r0),y
    sta $00       
    iny
    lda (cx16.r0),y
    sta cx16.r2L
    iny
    lda (cx16.r0),y
    sta cx16.r2H 

    ply
    lda (cx16.r2),y 
    iny
    phy
    ldy #$00
    sta (cx16.r1),y
    ply
    lda (cx16.r2),y 
    ldy #$01
    sta (cx16.r1),y
  rts
	.pend
	.pend

; ---- block: 'p8_fptr' ----
p8_fptr	.proc
	; source: src\fstruct.p8:165   fptr {
	p8_SIZEOF_FPTR = 3
	p8_compare_equal = 0
	p8_compare_greater = 1
	p8_compare_less = -1

; non-zeropage variables
p8_NULL	.char  $00, $00, $00

	; source: src\fstruct.p8:167   const ubyte SIZEOF_FPTR = 3;
	; source: src\fstruct.p8:168   byte[] NULL = [0,0,0];
	; source: src\fstruct.p8:184   const byte compare_equal = 0;
	; source: src\fstruct.p8:185   const byte compare_greater = 1;
	; source: src\fstruct.p8:186   const byte compare_less = -1;
	; source: src\fstruct.p8:170   asmsub b2p(ubyte bank @A, uword ptr @R1, uword fptr @R0) clobbers (Y)

p8_b2p	.proc
	; source: src\fstruct.p8:172   %asm {{
      
    ldy #$00
    sta (cx16.r0)
    iny 
    lda cx16.r1L
    sta (cx16.r0),y  
    iny 
    lda cx16.r1H
    sta (cx16.r0),y
  rts
	.pend
	; source: src\fstruct.p8:188   sub isnull(ubyte[fptr.SIZEOF_FPTR] ptr1) -> bool {

p8_isnull	.proc
p8_ptr1 	= 113 	; zp UWORD
; simple int arg(s) passed via register(s)
	sta  p8_ptr1
	sty  p8_ptr1+1
; statements
	; source: src\fstruct.p8:189   return ((ptr1[0] == 0) and (ptr1[1] == 0) and (ptr1[1] == 0));
	ldy  #0
	lda  (p8_ptr1),y
	beq  +
	lda  #1
+                           eor  #1
	pha
	ldy  #1
	lda  (p8_ptr1),y
	beq  +
	lda  #1
+                           eor  #1
	sta  P8ZP_SCRATCH_B1
	pla
	and  P8ZP_SCRATCH_B1
	pha
	ldy  #1
	lda  (p8_ptr1),y
	beq  +
	lda  #1
+                           eor  #1
	sta  P8ZP_SCRATCH_B1
	pla
	and  P8ZP_SCRATCH_B1
	rts
; variables
	.section BSS
	.send BSS

	.pend
	; source: src\fstruct.p8:192   sub compare(ubyte[fptr.SIZEOF_FPTR] ptr1, ubyte[fptr.SIZEOF_FPTR] ptr2) -> byte {

p8_compare	.proc
p8_ptr2 	= 115 	; zp UWORD
p8_ptr1 	= 117 	; zp UWORD
p8_addr2 	= 119 	; zp UWORD
; statements
	; source: src\fstruct.p8:199   uword addr2 = mkword(ptr2[2], ptr2[1]);
	; source: src\fstruct.p8:198   uword addr1 = mkword(ptr1[2], ptr1[1]);
	; source: src\fstruct.p8:193   if ptr1[0] > ptr2[0] {
	ldy  #0
	lda  (p8_ptr2),y
	sta  P8ZP_SCRATCH_B1
	ldy  #0
	lda  (p8_ptr1),y
	cmp  P8ZP_SCRATCH_B1
	bcc  prog8_label_asm_18_if_end
	beq  prog8_label_asm_18_if_end
	; source: src\fstruct.p8:194   return compare_greater
	lda  #1
	rts
prog8_label_asm_18_if_end
	; source: src\fstruct.p8:195   } else if ptr1[0] < ptr2[0] {
	ldy  #0
	lda  (p8_ptr2),y
	sta  P8ZP_SCRATCH_B1
	ldy  #0
	lda  (p8_ptr1),y
	cmp  P8ZP_SCRATCH_B1
	bcs  prog8_label_asm_19_if_end
	; source: src\fstruct.p8:196   return compare_less
	lda  #-1
	rts
prog8_label_asm_19_if_end
	; source: src\fstruct.p8:198   uword addr1 = mkword(ptr1[2], ptr1[1]);
	ldy  #1
	lda  (p8_ptr1),y
	pha
	ldy  #2
	lda  (p8_ptr1),y
	tay
	pla
	sta  p8_addr1
	sty  p8_addr1+1
	; source: src\fstruct.p8:199   uword addr2 = mkword(ptr2[2], ptr2[1]);
	ldy  #1
	lda  (p8_ptr2),y
	pha
	ldy  #2
	lda  (p8_ptr2),y
	tay
	pla
	sta  p8_addr2
	sty  p8_addr2+1
	; source: src\fstruct.p8:200   if addr1 > addr2 {
	ldy  p8_addr1+1
	lda  p8_addr1
	cpy  p8_addr2+1
	bcc  prog8_label_asm_20_if_end
	bne  +
	cmp  p8_addr2
	bcc  prog8_label_asm_20_if_end
+               beq  prog8_label_asm_20_if_end
	; source: src\fstruct.p8:201   return compare_greater
	lda  #1
	rts
prog8_label_asm_20_if_end
	; source: src\fstruct.p8:202   } else if addr1 < addr2 {
	ldy  p8_addr1+1
	lda  p8_addr1
	cpy  p8_addr2+1
	bcc  +
	bne  prog8_label_asm_21_if_end
	cmp  p8_addr2
	bcs  prog8_label_asm_21_if_end
+
	; source: src\fstruct.p8:203   return compare_less
	lda  #-1
	rts
prog8_label_asm_21_if_end
	; source: src\fstruct.p8:205   return compare_equal
	lda  #0
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_addr1	.word  ?
	.send BSS
	.pend
	; source: src\fstruct.p8:210   asmsub set(uword fptr @R0, uword valuePointer @R1) clobbers (Y) {

p8_set	.proc
	; source: src\fstruct.p8:211   %asm {{
     
    ; Set Bank and extract pointer
    ldy #$00
    lda (cx16.r0),y
    sta $00       
    iny
    lda (cx16.r0),y
    sta cx16.r2L
    iny
    lda (cx16.r0),y
    sta cx16.r2H    
                            
    ldy #$00
    lda (cx16.r1),Y   
    sta (cx16.r2),Y    
    iny    
    lda (cx16.r1),Y    
    sta (cx16.r2),Y
    iny    
    lda (cx16.r1),Y    
    sta (cx16.r2),Y
  rts
	.pend
	; source: src\fstruct.p8:235   asmsub get(uword fptr @R0, uword valuePointer @R1) clobbers (Y) {

p8_get	.proc
	; source: src\fstruct.p8:236   %asm {{
     
    ; Set Bank and extract pointer
    ldy #$00
    lda (cx16.r0),y
    sta $00       
    iny
    lda (cx16.r0),y
    sta cx16.r2L
    iny
    lda (cx16.r0),y
    sta cx16.r2H
    
    ldy #$00
    lda(cx16.r2),y                
    sta(cx16.r1),y    
    iny
    lda(cx16.r2),y            
    sta(cx16.r1),y
    iny
    lda(cx16.r2),y            
    sta(cx16.r1),y
  rts
	.pend
	; source: src\fstruct.p8:260   asmsub memcopy_in(uword fptr @R0, uword valuePointer @R1, ubyte count @X) clobbers (Y) {

p8_memcopy_in	.proc
	; source: src\fstruct.p8:261   %asm {{
     
    ; Set Bank and extract pointer
    ldy #$00
    lda (cx16.r0),y
    sta $00       
    iny
    lda (cx16.r0),y
    sta cx16.r2L
    iny
    lda (cx16.r0),y
    sta cx16.r2H    

    ldy #$00
    -                        
    lda (cx16.r1),y   
    sta (cx16.r2),y    
    iny    
    dex
    bne -
  rts
	.pend
	; source: src\fstruct.p8:284   asmsub memcopy_out(uword fptr @R0, uword valuePointer @R1, ubyte count @X) clobbers (Y) {

p8_memcopy_out	.proc
	; source: src\fstruct.p8:285   %asm {{
     
    ; Set Bank and extract pointer
    ldy #$00
    lda (cx16.r0),y
    sta $00       
    iny
    lda (cx16.r0),y
    sta cx16.r2L
    iny
    lda (cx16.r0),y
    sta cx16.r2H    

    ldy #$00
    -                    
    lda (cx16.r2),y 
    sta (cx16.r1),y    
    iny    
    dex
    bne -
  rts
	.pend
	.pend

; ---- block: 'p8_linkedlist_item' ----
p8_linkedlist_item	.proc
	; source: src\linkedlist.p8:5   %import fmalloc
	p8_LINKED_LIST_ITEM_SIZEOF = 10
	p8_LINKED_LIST_ITEM_data = 6
	p8_LINKED_LIST_ITEM_next = 0
	p8_LINKED_LIST_ITEM_prev = 3


	; source: src\linkedlist.p8:6   
	; source: src\linkedlist.p8:7   
	; source: src\linkedlist.p8:8   
	; source: src\linkedlist.p8:9   linkedlist_item {
	; source: src\linkedlist.p8:11   const ubyte LINKED_LIST_ITEM_SIZEOF         = $0a;

p8_next_get	.proc
p8_result 	= 69 	; zp UWORD
p8_ptr 	= 71 	; zp UWORD
; statements
	; source: src\linkedlist.p8:12   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  p8_result
	sta  cx16.r1
	lda  p8_result+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_get
	; source: src\linkedlist.p8:11   const ubyte LINKED_LIST_ITEM_SIZEOF         = $0a;
; variables
	.section BSS
	.send BSS

	.pend
	; source: src\linkedlist.p8:15   const ubyte LINKED_LIST_ITEM_prev           = $03; ubyte[fptr.SIZEOF_FPTR]

p8_next_set	.proc
p8_value 	= 65 	; zp UWORD
p8_ptr 	= 67 	; zp UWORD
; statements
	; source: src\linkedlist.p8:16   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_set
	; source: src\linkedlist.p8:15   const ubyte LINKED_LIST_ITEM_prev           = $03; ubyte[fptr.SIZEOF_FPTR]
; variables
	.section BSS
	.send BSS

	.pend
	; source: src\linkedlist.p8:19   

p8_prev_get	.proc
p8_result 	= 61 	; zp UWORD
p8_ptr 	= 63 	; zp UWORD
; statements
	; source: src\linkedlist.p8:20   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  #3
	sta  cx16.r2
	stz  cx16.r2+1
	lda  p8_result
	sta  cx16.r1
	lda  p8_result+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_get
	; source: src\linkedlist.p8:19   
; variables
	.section BSS
	.send BSS

	.pend
	; source: src\linkedlist.p8:23   fstruct.get(ptr, LINKED_LIST_ITEM_next, fptr.SIZEOF_FPTR, result);

p8_prev_set	.proc
p8_value 	= 57 	; zp UWORD
p8_ptr 	= 59 	; zp UWORD
; statements
	; source: src\linkedlist.p8:24   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  #3
	sta  cx16.r2
	stz  cx16.r2+1
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_set
	; source: src\linkedlist.p8:23   fstruct.get(ptr, LINKED_LIST_ITEM_next, fptr.SIZEOF_FPTR, result);
; variables
	.section BSS
	.send BSS

	.pend
	; source: src\linkedlist.p8:27   

p8_data_get	.proc
p8_result 	= 77 	; zp UWORD
p8_ptr 	= 79 	; zp UWORD
; statements
	; source: src\linkedlist.p8:28   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  #6
	sta  cx16.r2
	stz  cx16.r2+1
	lda  p8_result
	sta  cx16.r1
	lda  p8_result+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_get
	; source: src\linkedlist.p8:27   
; variables
	.section BSS
	.send BSS

	.pend
	; source: src\linkedlist.p8:31   fstruct.set(ptr, LINKED_LIST_ITEM_next, fptr.SIZEOF_FPTR, value);

p8_data_set	.proc
p8_value 	= 73 	; zp UWORD
p8_ptr 	= 75 	; zp UWORD
; statements
	; source: src\linkedlist.p8:32   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  #6
	sta  cx16.r2
	stz  cx16.r2+1
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_set
	; source: src\linkedlist.p8:31   fstruct.set(ptr, LINKED_LIST_ITEM_next, fptr.SIZEOF_FPTR, value);
; variables
	.section BSS
	.send BSS

	.pend
	.pend

; ---- block: 'p8_linkedlist_root' ----
p8_linkedlist_root	.proc
	; source: src\linkedlist.p8:37   sub prev_get(ubyte[3] ptr, uword result) {
	p8_LINKED_LIST_ROOT_SIZEOF = 6
	p8_LINKED_LIST_ROOT_head = 0
	p8_LINKED_LIST_ROOT_tail = 3


	; source: src\linkedlist.p8:38   
	; source: src\linkedlist.p8:39   fstruct.get(ptr, LINKED_LIST_ITEM_prev, fptr.SIZEOF_FPTR, result);
	; source: src\linkedlist.p8:40   
	; source: src\linkedlist.p8:42   

p8_head_get	.proc
p8_result 	= 53 	; zp UWORD
p8_ptr 	= 55 	; zp UWORD
; statements
	; source: src\linkedlist.p8:43   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  p8_result
	sta  cx16.r1
	lda  p8_result+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_get
	; source: src\linkedlist.p8:42   
; variables
	.section BSS
	.send BSS

	.pend
	; source: src\linkedlist.p8:46   

p8_head_set	.proc
p8_value 	= 49 	; zp UWORD
p8_ptr 	= 51 	; zp UWORD
; statements
	; source: src\linkedlist.p8:47   fstruct.set(ptr, LINKED_LIST_ITEM_prev, fptr.SIZEOF_FPTR, value);
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	stz  cx16.r2
	stz  cx16.r2+1
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_set
	; source: src\linkedlist.p8:46   
; variables
	.section BSS
	.send BSS

	.pend
	; source: src\linkedlist.p8:50   

p8_tail_get	.proc
p8_result 	= 45 	; zp UWORD
p8_ptr 	= 47 	; zp UWORD
; statements
	; source: src\linkedlist.p8:51   
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  #3
	sta  cx16.r2
	stz  cx16.r2+1
	lda  p8_result
	sta  cx16.r1
	lda  p8_result+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_get
	; source: src\linkedlist.p8:50   
; variables
	.section BSS
	.send BSS

	.pend
	; source: src\linkedlist.p8:54   

p8_tail_set	.proc
p8_value 	= 41 	; zp UWORD
p8_ptr 	= 43 	; zp UWORD
; statements
	; source: src\linkedlist.p8:55   fstruct.get(ptr, LINKED_LIST_ITEM_data, fptr.SIZEOF_FPTR, result);
	lda  p8_ptr
	sta  cx16.r0
	lda  p8_ptr+1
	sta  cx16.r0+1
	
	lda  #3
	sta  cx16.r2
	stz  cx16.r2+1
	lda  p8_value
	sta  cx16.r1
	lda  p8_value+1
	sta  cx16.r1+1
	
	ldx  #3
	jmp  p8_fstruct.p8_set
	; source: src\linkedlist.p8:54   
; variables
	.section BSS
	.send BSS

	.pend
	.pend

; ---- block: 'p8_linkedlist' ----
p8_linkedlist	.proc
	; source: src\linkedlist.p8:60   


	; source: src\linkedlist.p8:62   

p8_init	.proc
p8_root 	= 93 	; zp UWORD
p8_heap 	= 95 	; zp UWORD
; statements
	; source: src\linkedlist.p8:63   fstruct.set(ptr, LINKED_LIST_ITEM_data, fptr.SIZEOF_FPTR, value);
	lda  p8_heap
	ldy  p8_heap+1
	sta  p8_fmalloc.p8_malloc.p8_pm
	sty  p8_fmalloc.p8_malloc.p8_pm+1
	lda  #<6
	ldy  #>6
	sta  p8_fmalloc.p8_malloc.p8_size
	sty  p8_fmalloc.p8_malloc.p8_size+1
	
	lda  p8_root
	ldy  p8_root+1
	sta  p8_fmalloc.p8_malloc.p8_result
	sty  p8_fmalloc.p8_malloc.p8_result+1
	jsr  p8_fmalloc.p8_malloc
	; source: src\linkedlist.p8:64   
	lda  p8_root
	ldy  p8_root+1
	sta  p8_linkedlist_root.p8_head_set.p8_ptr
	sty  p8_linkedlist_root.p8_head_set.p8_ptr+1
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_linkedlist_root.p8_head_set.p8_value
	sty  p8_linkedlist_root.p8_head_set.p8_value+1
	
	jsr  p8_linkedlist_root.p8_head_set
	; source: src\linkedlist.p8:65   }
	lda  p8_root
	ldy  p8_root+1
	sta  p8_linkedlist_root.p8_tail_set.p8_ptr
	sty  p8_linkedlist_root.p8_tail_set.p8_ptr+1
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_linkedlist_root.p8_tail_set.p8_value
	sty  p8_linkedlist_root.p8_tail_set.p8_value+1
	
	jmp  p8_linkedlist_root.p8_tail_set
	; source: src\linkedlist.p8:62   
; variables
	.section BSS
	.send BSS

	.pend
	; source: src\linkedlist.p8:73   linkedlist_root {

p8_add_last	.proc
p8_root 	= 105 	; zp UWORD
p8_result 	= 107 	; zp UWORD
p8_heap 	= 109 	; zp UWORD
p8_data 	= 111 	; zp UWORD
; statements
	; source: src\linkedlist.p8:75   const ubyte LINKED_LIST_ROOT_SIZEOF = 6;
	; source: src\linkedlist.p8:76   
	; source: src\linkedlist.p8:77   const ubyte LINKED_LIST_ROOT_head   = $00; ubyte[fptr.SIZEOF_FPTR]
	; source: src\linkedlist.p8:80   
	lda  p8_heap
	ldy  p8_heap+1
	sta  p8_fmalloc.p8_malloc.p8_pm
	sty  p8_fmalloc.p8_malloc.p8_pm+1
	lda  #<10
	ldy  #>10
	sta  p8_fmalloc.p8_malloc.p8_size
	sty  p8_fmalloc.p8_malloc.p8_size+1
	
	lda  #<p8_pNew+0
	ldy  #>p8_pNew+0
	sta  p8_fmalloc.p8_malloc.p8_result
	sty  p8_fmalloc.p8_malloc.p8_result+1
	
	jsr  p8_fmalloc.p8_malloc
	; source: src\linkedlist.p8:83   sub head_get(ubyte[3] ptr, ubyte[3] result) {
	lda  #<p8_pNew+0
	ldy  #>p8_pNew+0
	sta  p8_linkedlist_item.p8_data_set.p8_ptr
	sty  p8_linkedlist_item.p8_data_set.p8_ptr+1
	
	lda  p8_data
	ldy  p8_data+1
	sta  p8_linkedlist_item.p8_data_set.p8_value
	sty  p8_linkedlist_item.p8_data_set.p8_value+1
	jsr  p8_linkedlist_item.p8_data_set
	; source: src\linkedlist.p8:86   
	lda  #<p8_pNew+0
	ldy  #>p8_pNew+0
	sta  p8_linkedlist_item.p8_next_set.p8_ptr
	sty  p8_linkedlist_item.p8_next_set.p8_ptr+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_linkedlist_item.p8_next_set.p8_value
	sty  p8_linkedlist_item.p8_next_set.p8_value+1
	
	jsr  p8_linkedlist_item.p8_next_set
	; source: src\linkedlist.p8:89   
	lda  p8_root
	ldy  p8_root+1
	sta  p8_linkedlist_root.p8_head_get.p8_ptr
	sty  p8_linkedlist_root.p8_head_get.p8_ptr+1
	lda  #<p8_pHead+0
	ldy  #>p8_pHead+0
	sta  p8_linkedlist_root.p8_head_get.p8_result
	sty  p8_linkedlist_root.p8_head_get.p8_result+1
	
	jsr  p8_linkedlist_root.p8_head_get
	; source: src\linkedlist.p8:90   
	ldy  #>p8_pHead+0
	lda  #<p8_pHead+0
	jsr  p8_fptr.p8_isnull
	cmp  #0
	beq  prog8_label_asm_22_if_else
	; source: src\linkedlist.p8:93   fstruct.set(ptr, LINKED_LIST_ROOT_head, fptr.SIZEOF_FPTR, value);
	lda  p8_root
	ldy  p8_root+1
	sta  p8_linkedlist_root.p8_head_set.p8_ptr
	sty  p8_linkedlist_root.p8_head_set.p8_ptr+1
	lda  #<p8_pNew+0
	ldy  #>p8_pNew+0
	sta  p8_linkedlist_root.p8_head_set.p8_value
	sty  p8_linkedlist_root.p8_head_set.p8_value+1
	
	jsr  p8_linkedlist_root.p8_head_set
	; source: src\linkedlist.p8:96   
	lda  #<p8_pNew+0
	ldy  #>p8_pNew+0
	sta  p8_linkedlist_item.p8_prev_set.p8_ptr
	sty  p8_linkedlist_item.p8_prev_set.p8_ptr+1
	
	lda  #<p8_fptr.p8_NULL+0
	ldy  #>p8_fptr.p8_NULL+0
	sta  p8_linkedlist_item.p8_prev_set.p8_value
	sty  p8_linkedlist_item.p8_prev_set.p8_value+1
	
	jsr  p8_linkedlist_item.p8_prev_set
	bra  prog8_label_asm_23_if_end
prog8_label_asm_22_if_else
	; source: src\linkedlist.p8:101   fstruct.get(ptr, LINKED_LIST_ROOT_tail, fptr.SIZEOF_FPTR, result);
	lda  p8_root
	ldy  p8_root+1
	sta  p8_linkedlist_root.p8_tail_get.p8_ptr
	sty  p8_linkedlist_root.p8_tail_get.p8_ptr+1
	lda  #<p8_pTail+0
	ldy  #>p8_pTail+0
	sta  p8_linkedlist_root.p8_tail_get.p8_result
	sty  p8_linkedlist_root.p8_tail_get.p8_result+1
	
	jsr  p8_linkedlist_root.p8_tail_get
	; source: src\linkedlist.p8:104   
	lda  #<p8_pTail+0
	ldy  #>p8_pTail+0
	sta  p8_linkedlist_item.p8_next_set.p8_ptr
	sty  p8_linkedlist_item.p8_next_set.p8_ptr+1
	
	lda  #<p8_pNew+0
	ldy  #>p8_pNew+0
	sta  p8_linkedlist_item.p8_next_set.p8_value
	sty  p8_linkedlist_item.p8_next_set.p8_value+1
	
	jsr  p8_linkedlist_item.p8_next_set
	; source: src\linkedlist.p8:107   sub tail_set(ubyte[3] ptr, ubyte[3] value) {
	lda  #<p8_pNew+0
	ldy  #>p8_pNew+0
	sta  p8_linkedlist_item.p8_prev_set.p8_ptr
	sty  p8_linkedlist_item.p8_prev_set.p8_ptr+1
	
	lda  #<p8_pTail+0
	ldy  #>p8_pTail+0
	sta  p8_linkedlist_item.p8_prev_set.p8_value
	sty  p8_linkedlist_item.p8_prev_set.p8_value+1
	
	jsr  p8_linkedlist_item.p8_prev_set
prog8_label_asm_23_if_end
	; source: src\linkedlist.p8:112   
	lda  p8_root
	ldy  p8_root+1
	sta  p8_linkedlist_root.p8_tail_set.p8_ptr
	sty  p8_linkedlist_root.p8_tail_set.p8_ptr+1
	lda  #<p8_pNew+0
	ldy  #>p8_pNew+0
	sta  p8_linkedlist_root.p8_tail_set.p8_value
	sty  p8_linkedlist_root.p8_tail_set.p8_value+1
	
	jsr  p8_linkedlist_root.p8_tail_set
	; source: src\linkedlist.p8:115   }
	lda  p8_pNew+0
	ldy  #0
	sta  (p8_result),y
	; source: src\linkedlist.p8:116   
	lda  p8_pNew+1
	ldy  #1
	sta  (p8_result),y
	; source: src\linkedlist.p8:117   
	lda  p8_pNew+2
	ldy  #2
	sta  (p8_result),y
	; source: src\linkedlist.p8:73   linkedlist_root {
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_pHead	.fill  3
p8_pNew	.fill  3
p8_pTail	.fill  3
	.send BSS
	.pend
	; source: src\linkedlist.p8:130   

p8_first	.proc
p8_root 	= 101 	; zp UWORD
p8_result 	= 103 	; zp UWORD
; statements
	; source: src\linkedlist.p8:131   }
	; source: src\linkedlist.p8:132   
	lda  p8_root
	ldy  p8_root+1
	sta  p8_linkedlist_root.p8_head_get.p8_ptr
	sty  p8_linkedlist_root.p8_head_get.p8_ptr+1
	lda  #<p8_pTemp+0
	ldy  #>p8_pTemp+0
	sta  p8_linkedlist_root.p8_head_get.p8_result
	sty  p8_linkedlist_root.p8_head_get.p8_result+1
	
	jsr  p8_linkedlist_root.p8_head_get
	; source: src\linkedlist.p8:133   
	lda  p8_pTemp+0
	ldy  #0
	sta  (p8_result),y
	; source: src\linkedlist.p8:134   
	lda  p8_pTemp+1
	ldy  #1
	sta  (p8_result),y
	; source: src\linkedlist.p8:135   sub add_first(uword heap, ubyte[3] root, uword data, ubyte[fptr.SIZEOF_FPTR] result) {
	lda  p8_pTemp+2
	ldy  #2
	sta  (p8_result),y
	; source: src\linkedlist.p8:130   
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_pTemp	.fill  3
	.send BSS
	.pend
	; source: src\linkedlist.p8:138   

p8_last	.proc
p8_root 	= 89 	; zp UWORD
p8_result 	= 91 	; zp UWORD
; statements
	; source: src\linkedlist.p8:139   
	; source: src\linkedlist.p8:140   
	lda  p8_root
	ldy  p8_root+1
	sta  p8_linkedlist_root.p8_tail_get.p8_ptr
	sty  p8_linkedlist_root.p8_tail_get.p8_ptr+1
	lda  #<p8_pTemp+0
	ldy  #>p8_pTemp+0
	sta  p8_linkedlist_root.p8_tail_get.p8_result
	sty  p8_linkedlist_root.p8_tail_get.p8_result+1
	
	jsr  p8_linkedlist_root.p8_tail_get
	; source: src\linkedlist.p8:141   }
	lda  p8_pTemp+0
	ldy  #0
	sta  (p8_result),y
	; source: src\linkedlist.p8:142   
	lda  p8_pTemp+1
	ldy  #1
	sta  (p8_result),y
	; source: src\linkedlist.p8:143   
	lda  p8_pTemp+2
	ldy  #2
	sta  (p8_result),y
	; source: src\linkedlist.p8:138   
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_pTemp	.fill  3
	.send BSS
	.pend
	; source: src\linkedlist.p8:146   

p8_next	.proc
p8_result 	= 85 	; zp UWORD
p8_current 	= 87 	; zp UWORD
; statements
	; source: src\linkedlist.p8:147   
	; source: src\linkedlist.p8:148   
	lda  p8_current
	ldy  p8_current+1
	sta  p8_linkedlist_item.p8_next_get.p8_ptr
	sty  p8_linkedlist_item.p8_next_get.p8_ptr+1
	lda  #<p8_pTemp+0
	ldy  #>p8_pTemp+0
	sta  p8_linkedlist_item.p8_next_get.p8_result
	sty  p8_linkedlist_item.p8_next_get.p8_result+1
	
	jsr  p8_linkedlist_item.p8_next_get
	; source: src\linkedlist.p8:149   ubyte[fptr.SIZEOF_FPTR] pNew;
	lda  p8_pTemp+0
	ldy  #0
	sta  (p8_result),y
	; source: src\linkedlist.p8:150   
	lda  p8_pTemp+1
	ldy  #1
	sta  (p8_result),y
	; source: src\linkedlist.p8:151   ubyte[fptr.SIZEOF_FPTR] pHead;
	lda  p8_pTemp+2
	ldy  #2
	sta  (p8_result),y
	; source: src\linkedlist.p8:146   
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_pTemp	.fill  3
	.send BSS
	.pend
	; source: src\linkedlist.p8:154   

p8_prev	.proc
p8_result 	= 81 	; zp UWORD
p8_current 	= 83 	; zp UWORD
; statements
	; source: src\linkedlist.p8:155   
	; source: src\linkedlist.p8:156   
	lda  p8_current
	ldy  p8_current+1
	sta  p8_linkedlist_item.p8_prev_get.p8_ptr
	sty  p8_linkedlist_item.p8_prev_get.p8_ptr+1
	lda  #<p8_pTemp+0
	ldy  #>p8_pTemp+0
	sta  p8_linkedlist_item.p8_prev_get.p8_result
	sty  p8_linkedlist_item.p8_prev_get.p8_result+1
	
	jsr  p8_linkedlist_item.p8_prev_get
	; source: src\linkedlist.p8:157   ; Create the new object
	lda  p8_pTemp+0
	ldy  #0
	sta  (p8_result),y
	; source: src\linkedlist.p8:158   
	lda  p8_pTemp+1
	ldy  #1
	sta  (p8_result),y
	; source: src\linkedlist.p8:159   fmalloc.malloc(heap, linkedlist_item.LINKED_LIST_ITEM_SIZEOF, pNew);
	lda  p8_pTemp+2
	ldy  #2
	sta  (p8_result),y
	; source: src\linkedlist.p8:154   
	rts
; variables
	.section BSS
	.send BSS

; non-zeropage variables without initialization value
	.section BSS
p8_pTemp	.fill  3
	.send BSS
	.pend
	; source: src\linkedlist.p8:162   

p8_free	.proc
p8_root 	= 97 	; zp UWORD
p8_heap 	= 99 	; zp UWORD
; statements
	; source: src\linkedlist.p8:169   ; pNew->next = NULL, always, it's the last node
	lda  p8_heap
	ldy  p8_heap+1
	sta  p8_fmalloc.p8_free.p8_pm
	sty  p8_fmalloc.p8_free.p8_pm+1
	lda  p8_root
	ldy  p8_root+1
	sta  p8_fmalloc.p8_free.p8_ptr
	sty  p8_fmalloc.p8_free.p8_ptr+1
	jmp  p8_fmalloc.p8_free
	; source: src\linkedlist.p8:162   
; variables
	.section BSS
	.send BSS

	.pend
	.pend

; ---- block: 'math' ----
math	.proc
	; source: library:/prog8lib/math.p8:3   math {


	; source: library:/prog8lib/math.p8:4   %option no_symbol_prefixing
	; source: library:/prog8lib/math.p8:6   %asminclude "library:math.asm"
; Internal Math library routines - always included by the compiler
; Generic machine independent 6502 code.
;
;  some more interesting routines can be found here:
;	http://6502org.wikidot.com/software-math
;	http://codebase64.org/doku.php?id=base:6502_6510_maths
;       https://github.com/TobyLobster/multiply_test
;       https://github.com/TobyLobster/sqrt_test


multiply_bytes	.proc
	; -- multiply 2 bytes A and Y, result as byte in A  (signed or unsigned)
	; https://github.com/TobyLobster/multiply_test/blob/main/tests/mult29.a

_multiplicand    = P8ZP_SCRATCH_B1
_multiplier      = P8ZP_SCRATCH_REG

    sty  _multiplicand
    lsr  a
    sta  _multiplier
    lda  #0
    ldx  #2
-
    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier
    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier

    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier
    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier
    dex
    bne  -
    ; tay       ; if you want 16 bits result in AY, enable this again
    lda  _multiplier
    rts
		.pend


multiply_words	.proc
	; -- multiply two 16-bit words into a 32-bit result  (signed and unsigned)
	;      input: A/Y = first 16-bit number, multiply_words.multiplier = second 16-bit number
	;      output: multiply_words.result, 4-bytes/32-bits product, LSB order (low-to-high)  low 16 bits also in AY.

	; NOTE: the result (which includes the multiplier parameter on entry) is a 4-byte array.
	;       this routine could be faster if we could stick that into zeropage,
	;       but there currently is no way to use 4 consecutive bytes in ZP (without disabling irq and saving/restoring them)...

; mult62.a
; from: https://github.com/TobyLobster/multiply_test/blob/main/tests/mult62.a
; based on Dr Jefyll, http://forum.6502.org/viewtopic.php?f=9&t=689&start=0#p19958
; - adjusted to use fixed zero page addresses
; - removed 'decrement to avoid clc' as this is slower on average
; - rearranged memory use to remove final memory copy and give LSB first order to result
; - removed temp zp storage bytes
; - unrolled the outer loop
; - unrolled the two inner loops once
;
; 16 bit x 16 bit unsigned multiply, 32 bit result
; Average cycles:
; 93 bytes

_multiplicand    = P8ZP_SCRATCH_W2   ; 2 bytes
multiplier      = result

; 16 bit x 16 bit unsigned multiply, 32 bit result
;
; On Entry:
;   (multiplier, multiplier+1): two byte multiplier, four bytes needed for result
;   (multiplicand, multiplicand+1): two byte multiplicand
; On Exit:
;   (result, result+1, result+2, result+3): product

    sta  _multiplicand
    sty  _multiplicand+1

    lda  #0              ;
    sta  result+2        ; 16 bits of zero in A, result+2
                        ;  Note:    First 8 shifts are  A -> result+2 -> result
                        ;           Final 8 shifts are  A -> result+2 -> result+1

    ; --- 1st byte ---
    ldy  #4              ; count for inner loop
    lsr  result

    ; inner loop (8 times)
_inner_loop
    ; first time
    bcc +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                ; shift
    ror  result+2
    ror  result

    ; second time
    bcc +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                 ; shift
    ror  result+2
    ror  result

    dey
    bne  _inner_loop      ; go back for 1 more shift?

    ; --- 2nd byte ---
    ldy  #4              ; count for inner loop
    lsr  result+1

    ; inner loop (8 times)
_inner_loop2
    ; first time
    bcc  +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                ; shift
    ror  result+2
    ror  result+1

    ; second time
    bcc  +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                ; shift
    ror  result+2
    ror  result+1
    dey
    bne  _inner_loop2     ; go back for 1 more shift?

    sta  result+3        ; ms byte of hi-word of result

    lda  result
    ldy  result+1
    rts

result		.byte  0,0,0,0

		.pend


divmod_b_asm	.proc
	; signed byte division: make everything positive and fix sign afterwards
		sta  P8ZP_SCRATCH_B1
		tya
		eor  P8ZP_SCRATCH_B1
		php			; save sign
		lda  P8ZP_SCRATCH_B1
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
+		pha
		tya
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
		tay
+		pla
		jsr  divmod_ub_asm
		sta  _remainder
		plp
		bpl  +
		tya
		eor  #$ff
		sec
		adc  #0			; negate result
		tay
+		rts
_remainder	.byte  0
		.pend


divmod_ub_asm	.proc
	; -- divide A by Y, result quotient in Y, remainder in A   (unsigned)
	;    division by zero will result in quotient = 255 and remainder = original number
		sty  P8ZP_SCRATCH_REG
		sta  P8ZP_SCRATCH_B1

		lda  #0
		ldx  #8
		asl  P8ZP_SCRATCH_B1
-		rol  a
		cmp  P8ZP_SCRATCH_REG
		bcc  +
		sbc  P8ZP_SCRATCH_REG
+		rol  P8ZP_SCRATCH_B1
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
		rts
		.pend

divmod_w_asm	.proc
	; signed word division: make everything positive and fix sign afterwards
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  P8ZP_SCRATCH_W1+1
		eor  P8ZP_SCRATCH_W2+1
		php			; save sign
		lda  P8ZP_SCRATCH_W1+1
		bpl  +
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W1
		lda  #0
		sbc  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W1+1
+		lda  P8ZP_SCRATCH_W2+1
		bpl  +
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W2
		lda  #0
		sbc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W2+1
+		tay
		lda  P8ZP_SCRATCH_W2
		jsr  divmod_uw_asm
		plp			; restore sign
		bpl  +
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W2
		pha
		lda  #0
		sbc  P8ZP_SCRATCH_W2+1
		tay
		pla
+		rts
		.pend

divmod_uw_asm	.proc
	; -- divide two unsigned words (16 bit each) into 16 bit results
	;    input:  P8ZP_SCRATCH_W1 in ZP: 16 bit number, A/Y: 16 bit divisor
	;    output: P8ZP_SCRATCH_W2 in ZP: 16 bit remainder, A/Y: 16 bit division result
	;    division by zero will result in quotient = 65535 and remainder = divident


dividend = P8ZP_SCRATCH_W1
remainder = P8ZP_SCRATCH_W2
result = dividend ;save memory by reusing divident to store the result

		sta  _divisor
		sty  _divisor+1
		lda  #0	        	;preset remainder to 0
		sta  remainder
		sta  remainder+1
		ldx  #16	        ;repeat for each bit: ...

-		asl  dividend		;dividend lb & hb*2, msb -> Carry
		rol  dividend+1
		rol  remainder		;remainder lb & hb * 2 + msb from carry
		rol  remainder+1
		lda  remainder
		sec
		sbc  _divisor		;substract divisor to see if it fits in
		tay	       		;lb result -> Y, for we may need it later
		lda  remainder+1
		sbc  _divisor+1
		bcc  +			;if carry=0 then divisor didn't fit in yet

		sta  remainder+1	;else save substraction result as new remainder,
		sty  remainder
		inc  result		;and INCrement result cause divisor fit in 1 times

+		dex
		bne  -

		lda  result
		ldy  result+1
		rts
_divisor	.word 0
		.pend


randword	.proc
	; -- 16 bit pseudo random number generator into AY
	;    default seed = $00c2 $1137
        ;    routine from https://codebase64.org/doku.php?id=base:x_abc_random_number_generator_8_16_bit
		inc x1
		clc
x1=*+1
		lda #$00	;x1
c1=*+1
		eor #$c2	;c1
a1=*+1
		eor #$11	;a1
		sta a1
b1=*+1
		adc #$37	;b1
		sta b1
		lsr a
		eor a1
		adc c1
		sta c1
		ldy b1
		rts
		.pend

randbyte = randword    ; -- 8 bit pseudo random number generator into A (by just reusing randword)


; ----------- optimized multiplications (in-place A (byte) and ?? (word)) : ---------
mul_byte_3	.proc
		; A = A + A*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_3	.proc
		; AY = AY*2 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend


mul_byte_5	.proc
		; A = A*4 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_5	.proc
		; AY = AY*4 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend


mul_byte_6	.proc
		; A = (A*2 + A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
                clc
                adc  P8ZP_SCRATCH_REG
		asl  a
		rts
		.pend

mul_word_6	.proc
		; AY = (AY*2 + AY)*2
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		tay
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		tya
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_7	.proc
		; A = A*8 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_7	.proc
		; AY = AY*8 - AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		sbc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_9	.proc
		; A = A*8 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_9	.proc
		; AY = AY*8 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		rts
		.pend

mul_byte_10	.proc
		; A=(A*4 + A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		rts
		.pend

mul_word_10	.proc
		; AY=(AY*4 + AY)*2
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_11	.proc
		; A=(A*2 + A)*4 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

; mul_word_11 is skipped (too much code)

mul_byte_12	.proc
		; A=(A*2 + A)*4
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		rts
		.pend

mul_word_12	.proc
		; AY=(AY*2 + AY)*4
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_13	.proc
		; A=(A*2 + A)*4 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
                clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
                clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

; mul_word_13 is skipped (too much code)

mul_byte_14	.proc
		; A=(A*8 - A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
                sec
		sbc  P8ZP_SCRATCH_REG
                asl  a
		rts
		.pend

; mul_word_14 is skipped (too much code)

mul_byte_15	.proc
		; A=A*16 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_15	.proc
		; AY = AY * 16 - AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		sbc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_20	.proc
		; A=(A*4 + A)*4
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		rts
		.pend

mul_word_20	.proc
		; AY = AY * 10 * 2
		jsr  mul_word_10
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_25	.proc
		; A=(A*2 + A)*8 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_25	.proc
		; AY = (AY*2 + AY) *8 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_40	.proc
		and  #7
		tay
		lda  _forties,y
		rts
_forties	.byte  0*40, 1*40, 2*40, 3*40, 4*40, 5*40, 6*40, 7*40 & 255
		.pend

mul_word_40	.proc
		; AY = (AY*4 + AY)*8
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		asl  P8ZP_SCRATCH_W1
		rol  a
		asl  P8ZP_SCRATCH_W1
		rol  a
		asl  P8ZP_SCRATCH_W1
		rol  a
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_50	.proc
		and  #7
		tay
		lda  _fifties, y
		rts
_fifties	.byte  0*50, 1*50, 2*50, 3*50, 4*50, 5*50, 6*50 & 255, 7*50 & 255
		.pend

mul_word_50	.proc
		; AY = AY * 25 * 2
		jsr  mul_word_25
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_80	.proc
		and  #3
		tay
		lda  _eighties, y
		rts
_eighties	.byte  0*80, 1*80, 2*80, 3*80
		.pend

mul_word_80	.proc
		; AY = AY * 40 * 2
		jsr  mul_word_40
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_100	.proc
		and  #3
		tay
		lda  _hundreds, y
		rts
_hundreds	.byte  0*100, 1*100, 2*100, 3*100 & 255
		.pend

mul_word_100	.proc
		; AY = AY * 25 * 4
		jsr  mul_word_25
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_320	.proc
		; AY = A * 256 + A * 64	 (msb in Y doesn't matter)
		sta  P8ZP_SCRATCH_B1
		ldy  #0
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		pha
		clc
		lda  P8ZP_SCRATCH_B1
		adc  P8ZP_SCRATCH_REG
		tay
		pla
		rts
		.pend

mul_word_640	.proc
		; AY = (A * 2 * 320) (msb in Y doesn't matter)
		asl  a
		jmp  mul_word_320
		.pend


; ----------- end optimized multiplications -----------


; support for bit shifting that is too large to be unrolled:

lsr_byte_A	.proc
		; -- lsr signed byte in A times the value in Y
		cpy  #0
		beq  +
		cmp  #0
		bpl  lsr_ubyte_A
-       	sec
		ror  a
		dey
		bne  -
+		rts
		.pend

lsr_ubyte_A	.proc
		; -- lsr unsigned byte in A times the value in Y
		cpy  #0
		beq  +
-		lsr  a
		dey
		bne  -
+		rts
		.pend

asl_byte_A      .proc
		; -- asl any byte in A times the value in Y
		cpy  #0
		beq  +
-		asl  a
		dey
		bne  -
+		rts
		.pend


lsr_word_AY     .proc
		; -- lsr signed word in AY times the value in X
		cpx  #0
		beq  +
		cpy  #0
		bpl  lsr_uword_AY
		sty  P8ZP_SCRATCH_B1
-		sec
		ror  P8ZP_SCRATCH_B1
		ror  a
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
+		rts
		.pend

lsr_uword_AY    .proc
		; -- lsr unsigned word in AY times the value in X
		cpx  #0
		beq  +
		sty  P8ZP_SCRATCH_B1
-		lsr  P8ZP_SCRATCH_B1
		ror  a
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
+		rts
		.pend

asl_word_AY     .proc
		; -- asl any word in AY times the value in X
		cpx  #0
		beq  +
		sty  P8ZP_SCRATCH_B1
-               asl  a
		rol  P8ZP_SCRATCH_B1
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
+		rts
		.pend


square          .proc
; -- calculate square of signed word (actually -255..255) in AY, result in AY
; routine by Lee Davison, source: http://6502.org/source/integers/square.htm
; using this routine is a lot faster as doing a regular multiplication (for words)
;
; Calculates the 16 bit unsigned integer square of the signed 16 bit integer in
; Numberl/Numberh.  The result is always in the range 0 to 65025 and is held in
; Squarel/Squareh
;
; The maximum input range is only +/-255 and no checking is done to ensure that
; this is so.
;
; This routine is useful if you are trying to draw circles as for any circle
;
; x^2+y^2=r^2 where x and y are the co-ordinates of any point on the circle and
; r is the circle radius

numberl = P8ZP_SCRATCH_W1       ; number to square low byte
numberh = P8ZP_SCRATCH_W1+1     ; number to square high byte
squarel = P8ZP_SCRATCH_W2       ; square low byte
squareh = P8ZP_SCRATCH_W2+1     ; square high byte
tempsq = P8ZP_SCRATCH_B1        ; temp byte for intermediate result

	sta  numberl
	sty  numberh

        lda     #$00        ; clear a
        sta     squarel     ; clear square low byte
                            ; (no need to clear the high byte, it gets shifted out)
        lda	numberl     ; get number low byte
	ldx	numberh     ; get number high  byte
	bpl	_nonneg      ; if +ve don't negate it
                            ; else do a two's complement
	eor	#$ff        ; invert
        sec	            ; +1
	adc	#$00        ; and add it

_nonneg:
	sta	tempsq      ; save abs(number)
	ldx	#$08        ; set bit count

_nextr2bit:
	asl	squarel     ; low byte *2
	rol	squareh     ; high byte *2+carry from low
	asl	a           ; shift number byte
	bcc	_nosqadd     ; don't do add if c = 0
	tay                 ; save a
	clc                 ; clear carry for add
	lda	tempsq      ; get number
	adc	squarel     ; add number^2 low byte
	sta	squarel     ; save number^2 low byte
	lda	#$00        ; clear a
	adc	squareh     ; add number^2 high byte
	sta	squareh     ; save number^2 high byte
	tya                 ; get a back

_nosqadd:
	dex                 ; decrement bit count
	bne	_nextr2bit   ; go do next bit

	lda  squarel
	ldy  squareh
	rts

		.pend
	; source: library:/prog8lib/math.p8:8   asmsub sin8u(ubyte angle @A) clobbers(Y) -> ubyte @A {

sin8u	.proc
	; source: library:/prog8lib/math.p8:9   %asm {{
		tay
		lda  _sinecos8u,y
		rts
_sinecos8u	.byte  trunc(128.0 + 127.5 * sin(range(256+64) * rad(360.0/256.0)))
	.pend
	; source: library:/prog8lib/math.p8:17   asmsub cos8u(ubyte angle @A) clobbers(Y) -> ubyte @A {

cos8u	.proc
	; source: library:/prog8lib/math.p8:18   %asm {{
		tay
		lda  sin8u._sinecos8u+64,y
		rts
	.pend
	; source: library:/prog8lib/math.p8:25   asmsub sin8(ubyte angle @A) clobbers(Y) -> byte @A {

sin8	.proc
	; source: library:/prog8lib/math.p8:26   %asm {{
		tay
		lda  _sinecos8,y
		rts
_sinecos8	.char  trunc(127.0 * sin(range(256+64) * rad(360.0/256.0)))
	.pend
	; source: library:/prog8lib/math.p8:34   asmsub cos8(ubyte angle @A) clobbers(Y) -> byte @A {

cos8	.proc
	; source: library:/prog8lib/math.p8:35   %asm {{
		tay
		lda  sin8._sinecos8+64,y
		rts
	.pend
	; source: library:/prog8lib/math.p8:42   asmsub sinr8u(ubyte radians @A) clobbers(Y) -> ubyte @A {

sinr8u	.proc
	; source: library:/prog8lib/math.p8:43   %asm {{
		tay
		lda  _sinecosR8u,y
		rts
_sinecosR8u	.byte  trunc(128.0 + 127.5 * sin(range(180+45) * rad(360.0/180.0)))
	.pend
	; source: library:/prog8lib/math.p8:51   asmsub cosr8u(ubyte radians @A) clobbers(Y) -> ubyte @A {

cosr8u	.proc
	; source: library:/prog8lib/math.p8:52   %asm {{
		tay
		lda  sinr8u._sinecosR8u+45,y
		rts
	.pend
	; source: library:/prog8lib/math.p8:59   asmsub sinr8(ubyte radians @A) clobbers(Y) -> byte @A {

sinr8	.proc
	; source: library:/prog8lib/math.p8:60   %asm {{
		tay
		lda  _sinecosR8,y
		rts
_sinecosR8	.char  trunc(127.0 * sin(range(180+45) * rad(360.0/180.0)))
	.pend
	; source: library:/prog8lib/math.p8:68   asmsub cosr8(ubyte radians @A) clobbers(Y) -> byte @A {

cosr8	.proc
	; source: library:/prog8lib/math.p8:69   %asm {{
		tay
		lda  sinr8._sinecosR8+45,y
		rts
	.pend
	; source: library:/prog8lib/math.p8:76   asmsub rnd() -> ubyte @A {

rnd	.proc
	; source: library:/prog8lib/math.p8:77   %asm {{
            jmp  math.randbyte
	.pend
	; source: library:/prog8lib/math.p8:82   asmsub rndw() -> uword @AY {

rndw	.proc
	; source: library:/prog8lib/math.p8:83   %asm {{
            jmp  math.randword
	.pend
	; source: library:/prog8lib/math.p8:88   asmsub rndseed(uword seed1 @AY, uword seed2 @R0) clobbers(A,Y) {

rndseed	.proc
	; source: library:/prog8lib/math.p8:90   %asm {{
            sta  math.randword.x1
            sty  math.randword.c1
            lda  cx16.r0L
            sta  math.randword.a1
            lda  cx16.r0H
            sta  math.randword.b1
            rts
	.pend
	; source: library:/prog8lib/math.p8:101   asmsub log2(ubyte value @A) -> ubyte @Y {

log2	.proc
	; source: library:/prog8lib/math.p8:102   %asm {{
            sta  P8ZP_SCRATCH_B1
            lda  #$80
            ldy  #7
-           bit  P8ZP_SCRATCH_B1
            beq  +
            rts
+           dey
            bne  +
            rts
+           lsr  a
            bne  -
	.pend
	; source: library:/prog8lib/math.p8:117   asmsub log2w(uword value @AY) -> ubyte @Y {

log2w	.proc
	; source: library:/prog8lib/math.p8:118   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            lda  #<$8000
            sta  cx16.r0
            lda  #>$8000
            sta  cx16.r0+1
            ldy  #15
-           lda  P8ZP_SCRATCH_W1
            and  cx16.r0
            sta  P8ZP_SCRATCH_B1
            lda  P8ZP_SCRATCH_W1+1
            and  cx16.r0+1
            ora  P8ZP_SCRATCH_B1
            beq  +
            rts
+           dey
            bne  +
            rts
+           lsr  cx16.r0+1
            ror  cx16.r0
            jmp  -
	.pend
	; source: library:/prog8lib/math.p8:143   asmsub mul16_last_upper() -> uword @AY {

mul16_last_upper	.proc
	; source: library:/prog8lib/math.p8:151   %asm {{
            lda  multiply_words.result+2
            ldy  multiply_words.result+3
            rts
	.pend
	; source: library:/prog8lib/math.p8:192   asmsub direction_qd(ubyte quadrant @A, ubyte xdelta @X, ubyte ydelta @Y) -> ubyte @A {

direction_qd	.proc
	; source: library:/prog8lib/math.p8:200   %asm {{
x_delta = cx16.r0L
y_delta = cx16.r1L
quadrant = cx16.r2L
half_value = cx16.r3L
region_number = cx16.r4L
small = cx16.r5L
large = cx16.r5H

  sta quadrant
  sty y_delta
  stx x_delta
  cpx y_delta
  bcs _XGreaterOrEqualY

_XLessY:
  lda #16
  sta region_number
  stx small
  sty large
  bne _DetermineRegion

_XGreaterOrEqualY:
  lda #0
  sta region_number
  stx large
  sty small

_DetermineRegion:
  ; set A = small * 2.5
  lda small
  lsr a
  sta half_value
  lda small
  asl a
  bcs _SmallerQuotient
  clc
  adc half_value
  bcs _SmallerQuotient
  cmp large
  bcc _LargerQuotient

; S * 2.5 > L
_SmallerQuotient:
  ; set A = S * 1.25
  lsr half_value
  lda small
  clc
  adc half_value
  cmp large
  bcc _Region1 ; if S * 1.25 < L then goto Region1 (L / S > 1.25)
  bcs _Region0 ;                                   (L / S < 1.25)

; S * 2.5 < L
_LargerQuotient:
  ; set A = S * 7.5
  lda small
  asl a
  asl a
  asl a
  bcs _Region2
  sec
  sbc half_value
  cmp large
  bcc _Region3 ; if S * 7.5 < L then goto Region3 (L / S > 7.5)
  jmp _Region2 ;                                  (L / S < 7.5)

_Region0:
  ; L / S < 1.25. d=3,9,15,21
  jmp _LookupResult

_Region1:
  ; 1.25 < L / S < 2.5. d=2,4,8,10,14,16,20,22
  lda region_number
  clc
  adc #4
  sta region_number
  bpl _LookupResult

_Region2:
  ; 2.5 < L / S < 7.5. d=1,5,7,11,13,17,19,23
  lda region_number
  clc
  adc #8
  sta region_number
  bpl _LookupResult

_Region3:
  ; 7.5 < L / S. d=0,6,12,18
  lda region_number
  clc
  adc #12
  sta region_number

_LookupResult:
  lda quadrant
  clc
  adc region_number
  tax
  lda _quadrant_region_to_direction,x
  rts

_quadrant_region_to_direction:
  .byte  9, 3,15,21
  .byte 10, 2,14,22
  .byte 11, 1,13,23
  .byte 12, 0,12, 0
  .byte  9, 3,15,21
  .byte  8, 4,16,20
  .byte  7, 5,17,19
  .byte  6, 6,18,18
	.pend
	; source: library:/prog8lib/math.p8:315   asmsub atan2(ubyte x1 @R0, ubyte y1 @R1, ubyte x2 @R2, ubyte y2 @R3) -> ubyte @A {

atan2	.proc
	; source: library:/prog8lib/math.p8:321   %asm {{
x1 = cx16.r0L
y1 = cx16.r1L
x2 = cx16.r2L
y2 = cx16.r3L
octant = cx16.r4L			;; temporary zeropage variable

		lda x1
		sec
		sbc x2
		bcs *+4
		eor #$ff
		tax
		rol octant

		lda y1
		sec
		sbc y2
		bcs *+4
		eor #$ff
		tay
		rol octant

		lda log2_tab,x
		sec
		sbc log2_tab,y
		bcc *+4
		eor #$ff
		tax

		lda octant
		rol a
		and #%111
		tay

		lda atan_tab,x
		eor octant_adjust,y
		rts

octant_adjust
		.byte %00111111		;; x+,y+,|x|>|y|
		.byte %00000000		;; x+,y+,|x|<|y|
		.byte %11000000		;; x+,y-,|x|>|y|
		.byte %11111111		;; x+,y-,|x|<|y|
		.byte %01000000		;; x-,y+,|x|>|y|
		.byte %01111111		;; x-,y+,|x|<|y|
		.byte %10111111		;; x-,y-,|x|>|y|
		.byte %10000000		;; x-,y-,|x|<|y|


		;;;;;;;; atan(2^(x/32))*128/pi ;;;;;;;;

atan_tab
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$00,$00,$00
		.byte $00,$00,$00,$00,$00,$01,$01,$01
		.byte $01,$01,$01,$01,$01,$01,$01,$01
		.byte $01,$01,$01,$01,$01,$01,$01,$01
		.byte $01,$01,$01,$01,$01,$01,$01,$01
		.byte $01,$01,$01,$01,$01,$02,$02,$02
		.byte $02,$02,$02,$02,$02,$02,$02,$02
		.byte $02,$02,$02,$02,$02,$02,$02,$02
		.byte $03,$03,$03,$03,$03,$03,$03,$03
		.byte $03,$03,$03,$03,$03,$04,$04,$04
		.byte $04,$04,$04,$04,$04,$04,$04,$04
		.byte $05,$05,$05,$05,$05,$05,$05,$05
		.byte $06,$06,$06,$06,$06,$06,$06,$06
		.byte $07,$07,$07,$07,$07,$07,$08,$08
		.byte $08,$08,$08,$08,$09,$09,$09,$09
		.byte $09,$0a,$0a,$0a,$0a,$0b,$0b,$0b
		.byte $0b,$0c,$0c,$0c,$0c,$0d,$0d,$0d
		.byte $0d,$0e,$0e,$0e,$0e,$0f,$0f,$0f
		.byte $10,$10,$10,$11,$11,$11,$12,$12
		.byte $12,$13,$13,$13,$14,$14,$15,$15
		.byte $15,$16,$16,$17,$17,$17,$18,$18
		.byte $19,$19,$19,$1a,$1a,$1b,$1b,$1c
		.byte $1c,$1c,$1d,$1d,$1e,$1e,$1f,$1f


		;;;;;;;; log2(x)*32 ;;;;;;;;

log2_tab
		.byte $00,$00,$20,$32,$40,$4a,$52,$59
		.byte $60,$65,$6a,$6e,$72,$76,$79,$7d
		.byte $80,$82,$85,$87,$8a,$8c,$8e,$90
		.byte $92,$94,$96,$98,$99,$9b,$9d,$9e
		.byte $a0,$a1,$a2,$a4,$a5,$a6,$a7,$a9
		.byte $aa,$ab,$ac,$ad,$ae,$af,$b0,$b1
		.byte $b2,$b3,$b4,$b5,$b6,$b7,$b8,$b9
		.byte $b9,$ba,$bb,$bc,$bd,$bd,$be,$bf
		.byte $c0,$c0,$c1,$c2,$c2,$c3,$c4,$c4
		.byte $c5,$c6,$c6,$c7,$c7,$c8,$c9,$c9
		.byte $ca,$ca,$cb,$cc,$cc,$cd,$cd,$ce
		.byte $ce,$cf,$cf,$d0,$d0,$d1,$d1,$d2
		.byte $d2,$d3,$d3,$d4,$d4,$d5,$d5,$d5
		.byte $d6,$d6,$d7,$d7,$d8,$d8,$d9,$d9
		.byte $d9,$da,$da,$db,$db,$db,$dc,$dc
		.byte $dd,$dd,$dd,$de,$de,$de,$df,$df
		.byte $df,$e0,$e0,$e1,$e1,$e1,$e2,$e2
		.byte $e2,$e3,$e3,$e3,$e4,$e4,$e4,$e5
		.byte $e5,$e5,$e6,$e6,$e6,$e7,$e7,$e7
		.byte $e7,$e8,$e8,$e8,$e9,$e9,$e9,$ea
		.byte $ea,$ea,$ea,$eb,$eb,$eb,$ec,$ec
		.byte $ec,$ec,$ed,$ed,$ed,$ed,$ee,$ee
		.byte $ee,$ee,$ef,$ef,$ef,$ef,$f0,$f0
		.byte $f0,$f1,$f1,$f1,$f1,$f1,$f2,$f2
		.byte $f2,$f2,$f3,$f3,$f3,$f3,$f4,$f4
		.byte $f4,$f4,$f5,$f5,$f5,$f5,$f5,$f6
		.byte $f6,$f6,$f6,$f7,$f7,$f7,$f7,$f7
		.byte $f8,$f8,$f8,$f8,$f9,$f9,$f9,$f9
		.byte $f9,$fa,$fa,$fa,$fa,$fa,$fb,$fb
		.byte $fb,$fb,$fb,$fc,$fc,$fc,$fc,$fc
		.byte $fd,$fd,$fd,$fd,$fd,$fd,$fe,$fe
		.byte $fe,$fe,$fe,$ff,$ff,$ff,$ff,$ff
	.pend
	.pend

; ---- block: 'prog8_lib' ----
prog8_lib	.proc
	; source: library:/prog8lib/prog8_lib.p8:3   prog8_lib {


	; source: library:/prog8lib/prog8_lib.p8:4   %option no_symbol_prefixing
	; source: library:/prog8lib/prog8_lib.p8:6   %asminclude "library:prog8_lib.asm"
; Internal library routines - always included by the compiler
; Generic machine independent 6502 code.


orig_stackpointer	.byte  0	; stores the Stack pointer register at program start


read_byte_from_address_in_AY_into_A	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		rts
		.pend


write_byte_X_to_address_in_AY	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		txa
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend


reg_less_uw	.proc
		;  AY < P8ZP_SCRATCH_W2?
		cpy  P8ZP_SCRATCH_W2+1
		bcc  _true
		bne  _false
		cmp  P8ZP_SCRATCH_W2
		bcc  _true
_false		lda  #0
		rts
_true		lda  #1
		rts
		.pend

reg_less_w	.proc
		; -- AY < P8ZP_SCRATCH_W2?
		cmp  P8ZP_SCRATCH_W2
		tya
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bmi  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

reg_lesseq_uw	.proc
		; AY <= P8ZP_SCRATCH_W2?
		cpy  P8ZP_SCRATCH_W2+1
		beq  +
		bcc  _true
		lda  #0
		rts
+		cmp  P8ZP_SCRATCH_W2
		bcc  _true
		beq  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

reg_lesseq_w	.proc
		; -- P8ZP_SCRATCH_W2 <= AY ?   (note: order different from other routines)
		cmp  P8ZP_SCRATCH_W2
		tya
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bpl  +
		lda  #0
		rts
+		lda  #1
		rts
		.pend


memcopy16_up	.proc
	; -- copy memory UP from (P8ZP_SCRATCH_W1) to (P8ZP_SCRATCH_W2) of length X/Y (16-bit, X=lo, Y=hi)
	;    clobbers register A,X,Y
		source = P8ZP_SCRATCH_W1
		dest = P8ZP_SCRATCH_W2
		length = P8ZP_SCRATCH_B1   ; (and SCRATCH_ZPREG)

		stx  length
		sty  length+1

		ldx  length             ; move low byte of length into X
		bne  +                  ; jump to start if X > 0
		dec  length             ; subtract 1 from length
+		ldy  #0                 ; set Y to 0
-		lda  (source),y         ; set A to whatever (source) points to offset by Y
		sta  (dest),y           ; move A to location pointed to by (dest) offset by Y
		iny                     ; increment Y
		bne  +                  ; if Y<>0 then (rolled over) then still moving bytes
		inc  source+1           ; increment hi byte of source
		inc  dest+1             ; increment hi byte of dest
+		dex                     ; decrement X (lo byte counter)
		bne  -                  ; if X<>0 then move another byte
		dec  length             ; we've moved 255 bytes, dec length
		bpl  -                  ; if length is still positive go back and move more
		rts                     ; done
		.pend


memset          .proc
	; -- fill memory from (P8ZP_SCRATCH_W1), length XY, with value in A.
	;    clobbers X, Y
		stx  P8ZP_SCRATCH_B1
		sty  _save_reg
		ldy  #0
		ldx  _save_reg
		beq  _lastpage

_fullpage	sta  (P8ZP_SCRATCH_W1),y
		iny
		bne  _fullpage
		inc  P8ZP_SCRATCH_W1+1          ; next page
		dex
		bne  _fullpage

_lastpage	ldy  P8ZP_SCRATCH_B1
		beq  +
-         	dey
		sta  (P8ZP_SCRATCH_W1),y
		bne  -

+           	rts
_save_reg	.byte  0
		.pend


memsetw		.proc
	; -- fill memory from (P8ZP_SCRATCH_W1) number of words in P8ZP_SCRATCH_W2, with word value in AY.
	;    clobbers A, X, Y
		sta  _mod1+1                    ; self-modify
		sty  _mod1b+1                   ; self-modify
		sta  _mod2+1                    ; self-modify
		sty  _mod2b+1                   ; self-modify
		ldx  P8ZP_SCRATCH_W1
		stx  P8ZP_SCRATCH_B1
		ldx  P8ZP_SCRATCH_W1+1
		inx
		stx  P8ZP_SCRATCH_REG                ; second page

		ldy  #0
		ldx  P8ZP_SCRATCH_W2+1
		beq  _lastpage

_fullpage
_mod1           lda  #0                         ; self-modified
		sta  (P8ZP_SCRATCH_W1),y        ; first page
		sta  (P8ZP_SCRATCH_B1),y            ; second page
		iny
_mod1b		lda  #0                         ; self-modified
		sta  (P8ZP_SCRATCH_W1),y        ; first page
		sta  (P8ZP_SCRATCH_B1),y            ; second page
		iny
		bne  _fullpage
		inc  P8ZP_SCRATCH_W1+1          ; next page pair
		inc  P8ZP_SCRATCH_W1+1          ; next page pair
		inc  P8ZP_SCRATCH_B1+1              ; next page pair
		inc  P8ZP_SCRATCH_B1+1              ; next page pair
		dex
		bne  _fullpage

_lastpage	ldx  P8ZP_SCRATCH_W2
		beq  _done

		ldy  #0
-
_mod2           lda  #0                         ; self-modified
                sta  (P8ZP_SCRATCH_W1), y
		inc  P8ZP_SCRATCH_W1
		bne  _mod2b
		inc  P8ZP_SCRATCH_W1+1
_mod2b          lda  #0                         ; self-modified
		sta  (P8ZP_SCRATCH_W1), y
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+               dex
		bne  -
_done		rts
		.pend



ror2_mem_ub	.proc
		; -- in-place 8-bit ror of byte at memory location in AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		lsr  a
		bcc  +
		ora  #$80
+		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend

rol2_mem_ub	.proc
		; -- in-place 8-bit rol of byte at memory location in AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		cmp  #$80
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend

rol_array_ub	.proc
		; -- rol a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  _arg_index
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend


ror_array_ub	.proc
		; -- ror a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  _arg_index
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend

ror2_array_ub	.proc
		; -- ror2 (8-bit ror) a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  _arg_index
		lda  (P8ZP_SCRATCH_W1),y
		lsr  a
		bcc  +
		ora  #$80
+		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend

rol2_array_ub	.proc
		; -- rol2 (8-bit rol) a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  _arg_index
		lda  (P8ZP_SCRATCH_W1),y
		cmp  #$80
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend

ror_array_uw	.proc
		; -- ror a uword in an array
		php
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  _arg_index
		asl  a
		tay
		iny
		lda  (P8ZP_SCRATCH_W1),y
		plp
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		dey
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend

rol_array_uw	.proc
		; -- rol a uword in an array
		php
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  _arg_index
		asl  a
		tay
		lda  (P8ZP_SCRATCH_W1),y
		plp
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend

rol2_array_uw	.proc
		; -- rol2 (16-bit rol) a uword in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  _arg_index
		asl  a
		tay
		lda  (P8ZP_SCRATCH_W1),y
		asl  a
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		bcc  +
		dey
		lda  (P8ZP_SCRATCH_W1),y
		adc  #0
		sta  (P8ZP_SCRATCH_W1),y
+		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend

ror2_array_uw	.proc
		; -- ror2 (16-bit ror) a uword in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  _arg_index
		asl  a
		tay
		iny
		lda  (P8ZP_SCRATCH_W1),y
		lsr  a
		sta  (P8ZP_SCRATCH_W1),y
		dey
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		bcc  +
		iny
		lda  (P8ZP_SCRATCH_W1),y
		ora  #$80
		sta  (P8ZP_SCRATCH_W1),y
+		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend


strcpy		.proc
		; copy a string (must be 0-terminated) from A/Y to (P8ZP_SCRATCH_W1)
		; it is assumed the target string is large enough.
		; returns the length of the string that was copied in Y.
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #$ff
-		iny
		lda  (P8ZP_SCRATCH_W2),y
		sta  (P8ZP_SCRATCH_W1),y
		bne  -
		rts
		.pend

strcmp_expression	.proc
		; -- compare strings, result in A
		lda  _arg_s2
		ldy  _arg_s2+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  _arg_s1
		ldy  _arg_s1+1
		jmp  strcmp_mem
_arg_s1		.word  0
_arg_s2		.word  0
		.pend

strcmp_mem	.proc
		; --   compares strings in s1 (AY) and s2 (P8ZP_SCRATCH_W2).
		;      Returns -1,0,1 in A, depeding on the ordering. Clobbers Y.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
_loop		lda  (P8ZP_SCRATCH_W1),y
		bne  +
		lda  (P8ZP_SCRATCH_W2),y
		bne  _return_minusone
		beq  _return
+		cmp  (P8ZP_SCRATCH_W2),y
		bcc  _return_minusone
		bne  _return_one
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+		inc  P8ZP_SCRATCH_W2
		bne  _loop
		inc  P8ZP_SCRATCH_W2+1
		bne  _loop
_return_one
		lda  #1
_return		rts
_return_minusone
		lda  #-1
		rts
		.pend


strlen          .proc
        ; -- returns the number of bytes in the string in AY, in Y.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  +
		iny
		bne  -
+		rts
		.pend


containment_bytearray	.proc
	; -- check if a value exists in a byte array.
	;    parameters: P8ZP_SCRATCH_W1: address of the byte array, A = byte to check, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
		dey
-		cmp  (P8ZP_SCRATCH_W1),y
		beq  +
		dey
		cpy  #255
		bne  -
		lda  #0
		rts
+		lda  #1
		rts
		.pend

containment_wordarray	.proc
	; -- check if a value exists in a word array.
	;    parameters: P8ZP_SCRATCH_W1: value to check, P8ZP_SCRATCH_W2: address of the word array, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
		dey
		tya
		asl  a
		tay
-		lda  P8ZP_SCRATCH_W1
		cmp  (P8ZP_SCRATCH_W2),y
		bne  +
		lda  P8ZP_SCRATCH_W1+1
		iny
		cmp  (P8ZP_SCRATCH_W2),y
		beq  _found
		dey
+		dey
		dey
		cpy  #254
		bne  -
		lda  #0
		rts
_found		lda  #1
		rts
		.pend
	; source: library:/prog8lib/prog8_lib.p8:7   %asminclude "library:prog8_funcs.asm"
; ---- builtin functions


func_any_b_into_A	.proc
		; -- any(array),  array in P8ZP_SCRATCH_W1, num bytes in A
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		bne  _got_any
		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #0
		rts
_got_any	lda  #1
		rts
		.pend


func_all_b_into_A	.proc
		; -- all(array),  array in P8ZP_SCRATCH_W1, num bytes in A
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  _got_not_all
		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #1
_got_not_all	rts
		.pend

func_any_w_into_A	.proc
		asl  a
		jmp  func_any_b_into_A
		.pend

func_all_w_into_A	.proc
		; -- all(warray),  array in P8ZP_SCRATCH_W1, num bytes in A
		asl  a			; times 2 because of word
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		bne  +
		iny
		lda  (P8ZP_SCRATCH_W1),y
		bne  ++
		lda  #0
		rts
+		iny
+		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #1
		rts
		.pend

abs_b_into_A	.proc
	; -- A = abs(A)
		cmp  #0
		bmi  +
		rts
+		eor  #$ff
		clc
		adc  #1
		rts
		.pend

abs_w_into_AY	.proc
	; -- AY = abs(AY)
		cpy  #0
		bmi  +
		rts
+		eor  #$ff
		pha
		tya
		eor  #$ff
		tay
		pla
		clc
		adc  #1
		bcc  +
		iny
+		rts
		.pend

func_sign_b_into_A	.proc
		cmp  #0
		beq  _zero
		bmi  _neg
		lda  #1
_zero		rts
_neg		lda  #-1
		rts
		.pend

func_sign_ub_into_A	.proc
		cmp  #0
		bne  _pos
		rts
_pos		lda  #1
		rts
		.pend

func_sign_uw_into_A	.proc
		cpy  #0
		beq  _possibly_zero
_pos		lda  #1
		rts
_possibly_zero	cmp  #0
		bne  _pos
		rts
		.pend

func_sign_w_into_A	.proc
		cpy  #0
		beq  _possibly_zero
		bmi  _neg
_pos		lda  #1
		rts
_neg		lda  #-1
		rts
_possibly_zero	cmp  #0
		bne  _pos
		rts
		.pend


func_sqrt16_into_A	.proc
		; integer square root
		; http://6502org.wikidot.com/software-math-sqrt
		; https://github.com/TobyLobster/sqrt_test/blob/main/sqrt/sqrt7.a
		; Tweaked by TobyLobster and 0xC0DE to be smaller and faster
_numl = P8ZP_SCRATCH_W1
_numh = P8ZP_SCRATCH_W1+1
_loop_counter = P8ZP_SCRATCH_REG
_root = P8ZP_SCRATCH_B1
            sta  _numl
            sty  _numh
            ldx  #$ff
            stx  _loop_counter
            inx
            stx  _root
            sec
_loop       lda  _numh
            sbc  #$40
            tay
            txa
            sbc  _root
            bcc  +
            sty  _numh
            bcs  ++
+           txa
+           rol  _root
            asl  _numl
            rol  _numh
            rol  a
            asl  _numl
            rol  _numh
            rol  a
            tax
            lsr  _loop_counter
            bne  _loop
            lda  _root
            rts
		.pend


func_sort_ub	.proc
		; 8bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in S
		; first, put pointer BEFORE array
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		bne  +
		dec  P8ZP_SCRATCH_W1+1
+		dec  P8ZP_SCRATCH_W1
_sortloop	ldy  P8ZP_SCRATCH_B1		;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y	;last value in (what is left of) sequence to be sorted
		sta  P8ZP_SCRATCH_REG		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2+1
		bcc  _l1
_l2		sty  P8ZP_SCRATCH_W2	;index of potentially largest value
		sta  P8ZP_SCRATCH_W2+1	;potentially largest value
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1		;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2+1	;the largest value
		sta  (P8ZP_SCRATCH_W1),y	;put largest value in place
		ldy  P8ZP_SCRATCH_W2	;index of free space
		lda  P8ZP_SCRATCH_REG		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y	;put the over-written value in the free space
		dec  P8ZP_SCRATCH_B1		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_b	.proc
		; 8bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first, put pointer BEFORE array
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		bne  +
		dec  P8ZP_SCRATCH_W1+1
+		dec  P8ZP_SCRATCH_W1
_sortloop	ldy  P8ZP_SCRATCH_B1		;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y	;last value in (what is left of) sequence to be sorted
		sta  P8ZP_SCRATCH_REG		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2+1
		bmi  _l1
_l2		sty  P8ZP_SCRATCH_W2	;index of potentially largest value
		sta  P8ZP_SCRATCH_W2+1	;potentially largest value
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1		;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2+1	;the largest value
		sta  (P8ZP_SCRATCH_W1),y	;put largest value in place
		ldy  P8ZP_SCRATCH_W2	;index of free space
		lda  P8ZP_SCRATCH_REG		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y	;put the over-written value in the free space
		dec  P8ZP_SCRATCH_B1		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_uw	.proc
		; 16bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		sec
		sbc  #2
		sta  P8ZP_SCRATCH_W1
		bcs  _sort_loop
		dec  P8ZP_SCRATCH_W1+1
_sort_loop	ldy  P8ZP_SCRATCH_B1    	;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		iny
		lda  (P8ZP_SCRATCH_W1),y
		dey
		cmp  P8ZP_SCRATCH_W2+1
		bne  +
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2
+		bcc  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2          ;potentially largest value
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2+1
		dey
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1           ;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2          ;the largest value
		sta  (P8ZP_SCRATCH_W1),y      ;put largest value in place
		iny
		lda  P8ZP_SCRATCH_W2+1
		sta  (P8ZP_SCRATCH_W1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (P8ZP_SCRATCH_W1),y
		dey
		dec  P8ZP_SCRATCH_B1           ;end of the shorter sequence still left
		dec  P8ZP_SCRATCH_B1
		bne  _sort_loop           ;start working with the shorter sequence
		rts
_work1	.byte  0
_work3	.word  0
		.pend


func_sort_w	.proc
		; 16bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		sec
		sbc  #2
		sta  P8ZP_SCRATCH_W1
		bcs  _sort_loop
		dec  P8ZP_SCRATCH_W1+1
_sort_loop	ldy  P8ZP_SCRATCH_B1    	;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2
		iny
		lda  (P8ZP_SCRATCH_W1),y
		dey
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bmi  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2          ;potentially largest value
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2+1
		dey
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1           ;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2          ;the largest value
		sta  (P8ZP_SCRATCH_W1),y      ;put largest value in place
		iny
		lda  P8ZP_SCRATCH_W2+1
		sta  (P8ZP_SCRATCH_W1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (P8ZP_SCRATCH_W1),y
		dey
		dec  P8ZP_SCRATCH_B1           ;end of the shorter sequence still left
		dec  P8ZP_SCRATCH_B1
		bne  _sort_loop           ;start working with the shorter sequence
		rts
_work1	.byte  0
_work3	.word  0
		.pend


func_reverse_b	.proc
		; --- reverse an array of bytes (in-place)
		; inputs:  pointer to array in P8ZP_SCRATCH_W1, length in A
_index_right = P8ZP_SCRATCH_W2
_index_left = P8ZP_SCRATCH_W2+1
_loop_count = P8ZP_SCRATCH_REG
		sta  _loop_count
		lsr  _loop_count
		sec
		sbc  #1
		sta  _index_right
		lda  #0
		sta  _index_left
_loop		ldy  _index_right
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_left
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_right
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_left
		sta  (P8ZP_SCRATCH_W1),y
		inc  _index_left
		dec  _index_right
		dec  _loop_count
		bne  _loop
		rts
		.pend


func_reverse_w	.proc
		; --- reverse an array of words (in-place)
		; inputs:  pointer to array in P8ZP_SCRATCH_W1, length in A
_index_first = P8ZP_SCRATCH_W2
_index_second = P8ZP_SCRATCH_W2+1
_loop_count = P8ZP_SCRATCH_REG
		pha
		asl  a     ; *2 because words
		sec
		sbc  #2
		sta  _index_first
		lda  #0
		sta  _index_second
		pla
		lsr  a
		pha
		sta  _loop_count
		; first reverse the lsbs
_loop_lo	ldy  _index_first
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_second
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_first
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_second
		sta  (P8ZP_SCRATCH_W1),y
		inc  _index_second
		inc  _index_second
		dec  _index_first
		dec  _index_first
		dec  _loop_count
		bne  _loop_lo
		; now reverse the msbs
		dec  _index_second
		inc  _index_first
		inc  _index_first
		inc  _index_first
		pla
		sta  _loop_count
_loop_hi	ldy  _index_first
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_second
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_first
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_second
		sta  (P8ZP_SCRATCH_W1),y
		dec  _index_second
		dec  _index_second
		inc  _index_first
		inc  _index_first
		dec  _loop_count
		bne  _loop_hi

		rts
		.pend


func_peekw   .proc
	; -- read the word value on the address in AY
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	pha
	iny
	lda  (P8ZP_SCRATCH_W1),y
	tay
	pla
	rts
	.pend


func_pokew   .proc
	; -- store the word value in AY in the address in P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_REG
	ldy  #0
	sta  (P8ZP_SCRATCH_W1),y
	iny
	lda  P8ZP_SCRATCH_REG
	sta  (P8ZP_SCRATCH_W1),y
	rts
	.pend


func_clamp_byte .proc
	; signed value in A, result in A
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W1+1
	tay
	sec
	sbc  P8ZP_SCRATCH_W1+1
	bvc  +
	eor  #$80
+       bmi  +
	lda  P8ZP_SCRATCH_W1+1
	tay
	jmp  ++
+       tya
+	sec
	sbc  P8ZP_SCRATCH_W1
	bvc  +
	eor  #$80
+       bmi  +
	tya
	rts
+       lda  P8ZP_SCRATCH_W1
	rts
	.pend


func_clamp_ubyte .proc
	; value in A, result in A
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W1+1
	cmp  P8ZP_SCRATCH_W1+1
	bcc  +
	lda  P8ZP_SCRATCH_W1+1
+       cmp  P8ZP_SCRATCH_W1
	bcc  +
	rts
+       lda  P8ZP_SCRATCH_W1
	rts
	.pend

func_clamp_word .proc
	; signed value in AY, result in AY
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W2
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_W2+1
	lda  P8ZP_SCRATCH_W2
	cmp  P8ZP_SCRATCH_B1
	tya
	sbc  P8ZP_SCRATCH_REG
	bvc  +
	eor  #$80
+       bpl  +
	lda  P8ZP_SCRATCH_W2
	ldy  P8ZP_SCRATCH_W2+1
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
+	ldy  P8ZP_SCRATCH_W1+1
	lda  P8ZP_SCRATCH_W1
	cmp  P8ZP_SCRATCH_B1
	tya
	sbc  P8ZP_SCRATCH_REG
	bvc  +
	eor  #$80
+       bpl  +
	ldy  P8ZP_SCRATCH_REG
	lda  P8ZP_SCRATCH_B1
	rts
+	ldy  P8ZP_SCRATCH_W1+1
	lda  P8ZP_SCRATCH_W1
	rts
	.pend

func_clamp_uword .proc
	; value in AY, result in AY
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W2
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
	cpy  P8ZP_SCRATCH_W2+1
	bcc  ++
	bne  +
	cmp  P8ZP_SCRATCH_W2
	bcc  ++
+       beq  +
	lda  P8ZP_SCRATCH_W2
	ldy  P8ZP_SCRATCH_W2+1
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
+	ldy  P8ZP_SCRATCH_REG
	lda  P8ZP_SCRATCH_B1
	cpy  P8ZP_SCRATCH_W1+1
	bcc  ++
	bne  +
	cmp  P8ZP_SCRATCH_W1
	bcc  ++
+       beq  +
	ldy  P8ZP_SCRATCH_REG
	lda  P8ZP_SCRATCH_B1
	rts
+	ldy  P8ZP_SCRATCH_W1+1
	lda  P8ZP_SCRATCH_W1
	rts

	.pend
	.pend
; global float constants
; bss sections
PROG8_VARSHIGH_RAMBANK = 1
prog8_bss_section_start
	.dsection BSS
prog8_bss_section_size = * - prog8_bss_section_start
prog8_program_end	; end of program label for progend()
